name: Deploy to STAGING (Windows Self-Hosted)

on:
  workflow_dispatch:

concurrency:
  group: deploy-staging
  cancel-in-progress: true

jobs:
  deploy_staging:
    if: ${{ runner.os == 'Windows' }}
    runs-on: [self-hosted, Windows]
    environment: staging
    timeout-minutes: 25

    defaults:
      run:
        shell: cmd

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      # --- LOGS: siapkan folder untuk semua log ------------------------------
      - name: Prepare logs folder
        shell: cmd
        run: |
          if not exist deploy_logs mkdir deploy_logs
          echo LOGDIR=%CD%\deploy_logs>>%GITHUB_ENV%

      # --- SQLCMD PATH (auto-detect) -----------------------------------------
      - name: Resolve sqlcmd.exe
        shell: powershell
        env:
          VAR_SQLCMD: ${{ vars.SQLCMD_EXE }}
        run: |
          $ErrorActionPreference = 'Stop'
          function Exists($p){ if([string]::IsNullOrWhiteSpace($p)){return $false}; Test-Path $p }
          $candidates = @()

          if ($env:VAR_SQLCMD) { $candidates += $env:VAR_SQLCMD }

          try {
            $found = & where.exe sqlcmd 2>$null
            if ($LASTEXITCODE -eq 0) {
              $candidates += ($found -split "`r?`n" | Where-Object { $_ -and (Test-Path $_) })
            }
          } catch {}

          $candidates += @(
            "C:\Program Files\SqlCmd\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe"
          )

          foreach($p in $candidates){
            if (Exists $p) {
              "SQLCMD_EXE=$p" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding Ascii
              Write-Host "Using sqlcmd: $p"
              exit 0
            }
          }
          Write-Error "sqlcmd.exe not found. Set repo variable SQLCMD_EXE or install SQLCMD tools."

      # --- PRE-FLIGHT CHECKS -------------------------------------------------
      - name: Echo target
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          if "%H%"=="" (
            echo Secret STG_DB_HOST is empty
            exit /b 1
          )
          echo Using sqlcmd: %SQLCMD_EXE%
          echo Target: %H%,%PORT% / DB=%D%

      - name: DNS resolve
        env:
          H: ${{ secrets.STG_DB_HOST }}
        run: nslookup %H% || (echo DNS FAILED & exit /b 1)

      - name: TCP port check
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          $port = if ($env:P) { $env:P } else { "1433" }
          if (-not (Test-NetConnection -ComputerName $env:H -Port ([int]$port) -InformationLevel Quiet)) {
            Write-Error "TCP connection to $($env:H):$port failed"
          } else {
            Write-Host "TCP OK to $($env:H):$port"
          }

      - name: Test sqlcmd login (SELECT 1)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -l 10 -b -C -Q "SELECT 1"
          if errorlevel 1 exit /b 1

      # --- SQL TYPE VALIDATION GUARD -----------------------------------------
      - name: Block disallowed types in deploy SQL (no MAX, no legacy LOB)
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          $files = Get-ChildItem -Path 'deploy' -Filter '*.sql' -Recurse -ErrorAction SilentlyContinue
          if (-not $files) { Write-Host "No SQL files under deploy/."; exit 0 }
          $patMax    = '\b(?:n?varchar|varbinary)\s*\(\s*max\s*\)'
          $patLegacy = '\b(?:text|ntext|image)\b'
          $bad1 = Select-String -Path $files.FullName -Pattern $patMax
          $bad2 = Select-String -Path $files.FullName -Pattern $patLegacy
          if ( ($bad1 | Measure-Object).Count -gt 0 -or ($bad2 | Measure-Object).Count -gt 0 ) {
            if ($bad1) { ($bad1.Path | Sort-Object -Unique) | ForEach-Object { Write-Host " - $_" } }
            if ($bad2) { ($bad2.Path | Sort-Object -Unique) | ForEach-Object { Write-Host " - $_" } }
            exit 1
          }
          Write-Host "Type guard passed."

      # --- SQL PARSE-ONLY (syntax check tanpa eksekusi) ----------------------
      - name: SQL parse-only (syntax check, no execution)
        shell: powershell
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
          LOGDIR: ${{ env.LOGDIR }}
        run: |
          $ErrorActionPreference='Stop'
          $port = if ($env:P) { $env:P } else { "1433" }
          $files = Get-ChildItem -Path 'deploy' -Filter '*.sql' -ErrorAction SilentlyContinue
          if (-not $files) { Write-Host "No SQL to parse."; exit 0 }

          foreach ($f in $files) {
            $wrap = Join-Path $env:LOGDIR ("__parse_" + $f.BaseName + ".sql")
            @(
              "SET PARSEONLY ON",
              ":r `"$($f.FullName)`"",
              "SET PARSEONLY OFF"
            ) | Set-Content -Path $wrap -Encoding ASCII

            Write-Host ("PARSEONLY -> {0}" -f $f.FullName)
            & "$env:SQLCMD_EXE" `
              -S "$($env:H),$port" -d "$($env:D)" -U "$($env:U)" -P "$env:W" `
              -b -C -i "$wrap" 2>&1 |
              Tee-Object -FilePath (Join-Path $env:LOGDIR "parseonly.log") -Append | Out-Host

            if ($LASTEXITCODE -ne 0) { throw ("Parse failed: {0}" -f $f.Name) }
          }


      # --- DEPLOYMENT --------------------------------------------------------
      - name: Deploy to STAGING (deploy/*.sql sorted)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
          LOGDIR: ${{ env.LOGDIR }}
        run: |
          setlocal enabledelayedexpansion
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"

          if not exist deploy\*.sql (
            echo No SQL files in deploy\ .
            exit /b 0
          )

          echo Running deploy scripts on %H%,%PORT% [DB=%D%] ...
          if not exist "%LOGDIR%" mkdir "%LOGDIR%"

          for /f "delims=" %%F in ('dir /b /o:n deploy\*.sql') do (
            set "OUTLOG=%LOGDIR%\%%~nF.out.txt"
            echo Executing %%F ... > "!OUTLOG!"
            "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -b -C -i "deploy\%%F" -o "!OUTLOG!"
            if errorlevel 1 (
              echo FAILED on %%F
              exit /b 1
            )
          )
          echo All deploy SQL executed successfully.

      # --- UPLOAD LOGS SELALU (bahkan kalau gagal) ---------------------------
      - name: Upload deploy logs
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: staging-deploy-logs
          path: |
            deploy_logs/**
            deploy/*.sql
          if-no-files-found: warn
