name: Deploy PRODUCTION (Windows Self-Hosted)

on:
  push:
    branches: [ main ]
    paths:
      - "deploy/**/*.sql"
      - "tables/**/*.yml"
      - "tables/**/*.yaml"
      - "rules.yml"
      - "scripts/metadata_validate_and_render.py"
      - ".github/workflows/deploy-prod-windows.yml"

# Jangan ada 2 deploy prod jalan bareng
concurrency:
  group: deploy-prod
  cancel-in-progress: true

permissions:
  contents: read

defaults:
  run:
    shell: cmd

jobs:
  deploy_prod:
    runs-on: [self-hosted, Windows]
    environment: production   # ← protection rules kick-in
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Use sqlcmd path from repo variable
        run: |
          echo SQLCMD_EXE=${{ vars.SQLCMD_EXE }}>>%GITHUB_ENV%
          if not exist "${{ vars.SQLCMD_EXE }}" (
            echo sqlcmd.exe not found at: ${{ vars.SQLCMD_EXE }}
            exit /b 1
          )

      # ==== Preflight PROD (copy dari staging, pakai secrets PROD) ====
      - name: Echo target
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
          D: ${{ secrets.PROD_DB_NAME }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          if "%H%"=="" ( echo Secret PROD_DB_HOST is empty & exit /b 1 )
          echo Using sqlcmd: %SQLCMD_EXE%
          echo Target: %H%,%PORT% / DB=%D%

      - name: DNS resolve
        env:
          H: ${{ secrets.PROD_DB_HOST }}
        run: nslookup %H% || (echo DNS FAILED & exit /b 1)

      - name: TCP port check
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          powershell -Command "if(!(Test-NetConnection -ComputerName '%H%' -Port ([int]'%PORT%') -InformationLevel Quiet)){exit 1}"

      - name: Test sqlcmd login (SELECT 1)
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
          D: ${{ secrets.PROD_DB_NAME }}
          U: ${{ secrets.PROD_DB_USER }}
          W: ${{ secrets.PROD_DB_PASSWORD }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -l 10 -b -C -Q "SELECT 1"
          if errorlevel 1 exit /b 1

      # ==== QC guards + parse-only (copy dari staging) ====
      - name: Block disallowed types (MAX, legacy LOB)
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          $files = Get-ChildItem -Path 'deploy' -Filter '*.sql' -Recurse -ErrorAction SilentlyContinue
          if (-not $files) { Write-Host 'No SQL files under deploy/.'; exit 0 }
          $patMax    = '\b(?:n?varchar|varbinary)\s*\(\s*max\s*\)'
          $patLegacy = '\b(?:text|ntext|image)\b'
          if (Select-String -Path $files.FullName -Pattern $patMax)    { throw 'Contains (var|nvar)char(max)/varbinary(max)' }
          if (Select-String -Path $files.FullName -Pattern $patLegacy) { throw 'Contains legacy type (text/ntext/image)' }

      - name: Extra guards (optional)
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          $files = Get-ChildItem -Path 'deploy' -Filter '*.sql' -Recurse -ErrorAction SilentlyContinue
          if (-not $files) { exit 0 }
          $badAnsiNulls = '\bSET\s+ANSI_NULLS\s+OFF\b'
          $badQuotedId  = '\bSET\s+QUOTED_IDENTIFIER\s+OFF\b'
          if (Select-String -Path $files.FullName -Pattern $badAnsiNulls) { throw 'Found SET ANSI_NULLS OFF' }
          if (Select-String -Path $files.FullName -Pattern $badQuotedId)  { throw 'Found SET QUOTED_IDENTIFIER OFF' }

      - name: SQL parse-only (syntax check, no execution)
        shell: powershell
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
          D: ${{ secrets.PROD_DB_NAME }}
          U: ${{ secrets.PROD_DB_USER }}
          W: ${{ secrets.PROD_DB_PASSWORD }}
        run: |
          $ErrorActionPreference='Stop'
          $port = if ("${env:P}") { $env:P } else { "1433" }
          $files = Get-ChildItem -Path 'deploy' -Filter '*.sql' -ErrorAction SilentlyContinue
          if (-not $files) { Write-Host "No SQL to parse."; exit 0 }
          foreach ($f in $files) {
            Write-Host "PARSEONLY -> $($f.FullName)"
            & "${env:SQLCMD_EXE}" -S $env:H,$port -d $env:D -U $env:U -P $env:W -b -C -Q "SET PARSEONLY ON; :r `"$($f.FullName)`"; SET PARSEONLY OFF;"
            if ($LASTEXITCODE -ne 0) { throw "Parse failed: $($f.Name)" }
          }

      # ==== DEPLOY PROD ====
      - name: Deploy to PRODUCTION
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
          D: ${{ secrets.PROD_DB_NAME }}
          U: ${{ secrets.PROD_DB_USER }}
          W: ${{ secrets.PROD_DB_PASSWORD }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          if exist deploy\*.sql (
            for /f "delims=" %%F in ('dir /b /o:n deploy\*.sql') do (
              echo Executing %%~nxF ...
              "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -b -C -i "deploy\%%F"
              if errorlevel 1 (
                echo FAILED on %%~nxF
                exit /b 1
              )
            )
          ) else (
            echo _No SQL files in deploy/._
          )
