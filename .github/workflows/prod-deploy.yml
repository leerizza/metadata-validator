name: Deploy to Production (manual trigger, with backup)

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: "Ketik 'YES' untuk konfirmasi deploy ke PRODUCTION"
        required: true
        default: "NO"

concurrency:
  group: prod-deploy
  cancel-in-progress: false

defaults:
  run:
    shell: cmd

jobs:
  deploy_prod:
    name: Deploy to Production
    runs-on: [self-hosted, Windows]
    environment: production
    if: ${{ github.event.inputs.confirm == 'YES' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Cari sqlcmd.exe (pakai repo variable SQLCMD_EXE kalau ada)
      - name: Resolve sqlcmd
        shell: powershell
        env:
          VAR_SQLCMD: ${{ vars.SQLCMD_EXE }}
        run: |
          $ErrorActionPreference='Stop'
          function Exists($p){ if([string]::IsNullOrWhiteSpace($p)){return $false}; Test-Path $p }
          $c=@()
          if($env:VAR_SQLCMD){ $c+=$env:VAR_SQLCMD }
          try{
            $found=& where.exe sqlcmd 2>$null
            if($LASTEXITCODE -eq 0){ $c+=($found -split "`r?`n" | ? { $_ -and (Test-Path $_) }) }
          }catch{}
          $c+@(
            "C:\Program Files\SqlCmd\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          )
          $pick=$c|?{Exists $_}|Select-Object -First 1
          if(-not $pick){ throw "sqlcmd.exe not found. Set repo variable SQLCMD_EXE or install SQL tools." }
          "SQLCMD_EXE=$pick" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
          Write-Host "Using sqlcmd: $pick"

      # Preflight koneksi ke PROD
      - name: Preflight Connection (DNS/TCP/login)
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
          D: ${{ secrets.PROD_DB_NAME }}
          U: ${{ secrets.PROD_DB_USER }}
          W: ${{ secrets.PROD_DB_PASSWORD }}
        run: |
          nslookup %H% || (echo ❌ DNS FAILED & exit /b 1)
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          powershell -Command "if(!(Test-NetConnection -ComputerName '%H%' -Port ([int]'%PORT%') -InformationLevel Quiet)){exit 1}"
          "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -l 10 -b -C -Q "SELECT 1"

      # Hitung file deploy/*.sql yang berubah di commit terakhir (bisa kamu ubah logikanya nanti)
      - name: Compute changed SQL (since last commit)
        id: changes
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          git config --global --add safe.directory "$env:GITHUB_WORKSPACE" 2>$null
          try { git fetch --all --tags --prune 2>$null } catch {}

          # Default: bandingkan HEAD~1...HEAD (commit terakhir)
          $range = 'HEAD~1...HEAD'
          $changed = git -c core.quotepath=false diff --name-only --diff-filter=AMR $range -- "deploy/*.sql"

          if ($changed) {
            $p='deploy\_changed_sql.txt'
            $changed | Sort-Object | Set-Content -Encoding UTF8 -LiteralPath $p
            "CHANGED_SQL_LIST=$p" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
            "has_changes=true"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "Changed SQL files (range $range):"
            Get-Content $p | % { " - $_" }
          } else {
            "has_changes=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "::notice title=No changed SQL::Skipping backup and deploy."
          }

      # (Baru) Generate & jalankan BACKUP sebelum eksekusi
      - name: Generate & Run Backup (for affected tables)
        if: steps.changes.outputs.has_changes == 'true'
        shell: powershell
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
          D: ${{ secrets.PROD_DB_NAME }}
          U: ${{ secrets.PROD_DB_USER }}
          W: ${{ secrets.PROD_DB_PASSWORD }}
        run: |
          $ErrorActionPreference='Stop'
          $list = Get-Content 'deploy\_changed_sql.txt'
          if(-not $list){ Write-Host "No changed list"; exit 0 }

          # Regex cari nama tabel dari CREATE TABLE & ALTER TABLE
          $rxCreate = [regex]'(?is)\bcreate\s+table\s+(?:\[?(?<s>\w+)\]?\.)?\[?(?<t>\w+)\]?'
          $rxAlter  = [regex]'(?is)\balter\s+table\s+(?:\[?(?<s>\w+)\]?\.)?\[?(?<t>\w+)\]?'

          $pairs=@()
          foreach($f in $list){
            if(Test-Path $f){
              $c = Get-Content $f -Raw
              foreach($m in $rxCreate.Matches($c)){
                $s = $m.Groups['s'].Success ? $m.Groups['s'].Value : 'dbo'
                $t = $m.Groups['t'].Value
                if($t){ $pairs += "$s.$t" }
              }
              foreach($m in $rxAlter.Matches($c)){
                $s = $m.Groups['s'].Success ? $m.Groups['s'].Value : 'dbo'
                $t = $m.Groups['t'].Value
                if($t){ $pairs += "$s.$t" }
              }
            }
          }
          $pairs = $pairs | Sort-Object -Unique
          if(-not $pairs){ Write-Host "No affected tables found. Skip backup."; exit 0 }

          $ts = Get-Date -Format yyyyMMddHHmmss
          $out = "deploy\__auto_backup_prod_$ts.sql"
          $sb = New-Object System.Text.StringBuilder
          $null = $sb.AppendLine('-- auto-generated backup script (PROD)')

          foreach($qn in $pairs){
            $schema,$table = $qn.Split('.')
            $qn2 = "[$schema].[$table]"
            $bk  = "[$schema].["+$table+"__bak_"+$ts+"]"
            [void]$sb.AppendLine("IF OBJECT_ID(N'$qn2','U') IS NOT NULL AND OBJECT_ID(N'$bk','U') IS NULL")
            [void]$sb.AppendLine("BEGIN SELECT * INTO $bk FROM $qn2 WITH (HOLDLOCK, TABLOCKX); END")
            [void]$sb.AppendLine("GO")
          }

          $sb.ToString() | Set-Content -LiteralPath $out -Encoding UTF8

          $port = $env:P; if([string]::IsNullOrWhiteSpace($port)){$port='1433'}
          & "$env:SQLCMD_EXE" -S $env:H,$port -d $env:D -U $env:U -P $env:W -b -C -i $out

      # Deploy hanya file yang berubah (berdasarkan daftar)
      - name: Deploy to PRODUCTION (changed only)
        if: steps.changes.outputs.has_changes == 'true'
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
          D: ${{ secrets.PROD_DB_NAME }}
          U: ${{ secrets.PROD_DB_USER }}
          W: ${{ secrets.PROD_DB_PASSWORD }}
        run: |
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          for /f "usebackq delims=" %%F in (`type deploy\_changed_sql.txt`) do (
            if exist "%%F" (
              echo 🚀 Executing %%~nxF on Production...
              "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -b -C -i "%%F" || exit /b 1
            )
          )

      - name: Upload deploy logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: production-deploy-logs
          path: |
            deploy_logs_prod/**
            deploy/*.sql
          if-no-files-found: warn
