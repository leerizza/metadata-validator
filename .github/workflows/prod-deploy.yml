name: Deploy to PRODUCTION (Manual, Modular)

on:
  workflow_dispatch:
    inputs:
      target_ref:
        description: "Reference to deploy (tag/branch/commit)"
        required: true
        default: "main"
      note:
        description: "Catatan (opsional)"
        required: false
        default: ""

concurrency:
  group: prod-deploy
  cancel-in-progress: false

defaults:
  run:
    shell: cmd

jobs:
  compute_changes:
    runs-on: [self-hosted, Windows]
    outputs:
      has_create: ${{ steps.outvars.outputs.has_create }}
      has_alter:  ${{ steps.outvars.outputs.has_alter }}
      has_drop:   ${{ steps.outvars.outputs.has_drop }}
      create_count: ${{ steps.outvars.outputs.create_count }}
      alter_count:  ${{ steps.outvars.outputs.alter_count }}
      drop_count:   ${{ steps.outvars.outputs.drop_count }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.inputs.target_ref }}

      - name: Resolve sqlcmd
        shell: powershell
        env:
          VAR_SQLCMD: ${{ vars.SQLCMD_EXE }}
        run: |
          $ErrorActionPreference='Stop'
          function Exists($p){ if([string]::IsNullOrWhiteSpace($p)){return $false}; Test-Path $p }
          $c=@()
          if($env:VAR_SQLCMD){ $c+=$env:VAR_SQLCMD }
          try{ $found=& where.exe sqlcmd 2>$null; if($LASTEXITCODE -eq 0){ $c+=($found -split "`r?`n" | Where-Object { $_ -and (Test-Path $_) }) } }catch{}
          $c+=@(
            "C:\Program Files\SqlCmd\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe"
          )
          $pick=$c|Where-Object { Exists $_ } | Select-Object -First 1
          if(-not $pick){ throw "sqlcmd.exe not found. Set repo variable SQLCMD_EXE or install SQL tools." }
          "SQLCMD_EXE=$pick" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
          Write-Host "Using sqlcmd: $pick"

      - name: Prep logs
        shell: powershell
        run: |
          $root = Join-Path $env:GITHUB_WORKSPACE 'deploy_logs_prod'
          if (!(Test-Path $root)) { New-Item -ItemType Directory -Path $root -Force | Out-Null }
          "LOGDIR=$root" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii

      - name: Preflight PROD
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
          D: ${{ secrets.PROD_DB_NAME }}
          U: ${{ secrets.PROD_DB_USER }}
          W: ${{ secrets.PROD_DB_PASSWORD }}
        run: |
          nslookup %H% || (echo ‚ùå DNS FAILED & exit /b 1)
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          powershell -Command "if(!(Test-NetConnection -ComputerName '%H%' -Port ([int]'%PORT%') -InformationLevel Quiet)){exit 1}"
          "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -l 10 -b -C -Q "SELECT 1"

      - name: Get last deployed commit
        id: last_deploy
        shell: powershell
        run: |
          # Cari tag terakhir yang menandakan deploy production
          $lastTag = git tag -l "prod-*" --sort=-creatordate | Select-Object -First 1
          if ($lastTag) {
            Write-Host "Last production tag: $lastTag"
            "LAST_DEPLOYED_REF=$lastTag" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
            "has_previous_deploy=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            Write-Host "No previous production tag found. Deploying all files."
            "LAST_DEPLOYED_REF=origin/main" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
            "has_previous_deploy=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

      - name: Compute changed files (CREATE/ALTER/DROP)
        id: compute
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          git config --global --add safe.directory "$env:GITHUB_WORKSPACE" 2>$null
          
          # Fetch semua branch dan tags
          try { 
            git fetch origin --depth=100 2>$null
            git fetch --all --tags --prune 2>$null 
          } catch {}
          
          # Tentukan range untuk diff
          $lastRef = $env:LAST_DEPLOYED_REF
          $currentRef = "HEAD"
          
          Write-Host "Comparing: $lastRef...$currentRef"
          Write-Host "Current branch: $(git branch --show-current)"
          Write-Host "Current HEAD: $(git rev-parse HEAD)"
          Write-Host "Last deployed ref: $lastRef"

          $lists=@{
            create = @{ pattern = "deploy/create/*.sql"; out="deploy\_changed_create.txt" };
            alter  = @{ pattern = "deploy/alter/*.sql";  out="deploy\_changed_alter.txt"  };
            drop   = @{ pattern = "deploy/drop/*.sql";   out="deploy\_changed_drop.txt"   };
          }

          $flags=@{ create=$false; alter=$false; drop=$false }
          $counts=@{ create=0; alter=0; drop=0 }

          foreach($k in $lists.Keys){
            $p=$lists[$k].pattern
            $o=$lists[$k].out
            
            Write-Host ""
            Write-Host "Checking $k files..."
            
            # Gunakan git diff dengan range yang benar
            $diff = git -c core.quotepath=false diff --name-only --diff-filter=AMR "$lastRef...$currentRef" -- $p 2>$null
            $all=@()
            if($diff){$all+=$diff}
            
            # Juga include files yang modified dalam working directory (untuk manual trigger)
            $wt = git ls-files -mo --exclude-standard -- $p 2>$null
            if($wt){$all+=$wt}
            
            # Filter hanya file yang benar-benar ada
            $all=$all | Where-Object { $_ -and (Test-Path $_) } | Sort-Object -Unique
            
            if($all.Count -gt 0){
              $all | Set-Content -LiteralPath $o -Encoding UTF8
              $flags[$k]=$true
              $counts[$k]=$all.Count
              Write-Host "[OK] $($k.ToUpper()) changed ($($all.Count) files):"
              $all | ForEach-Object { 
                Write-Host "   - $_" 
                if (Test-Path $_) {
                  $size = (Get-Item $_).Length
                  Write-Host "     Size: $size bytes"
                }
              }
            }
            else {
              Write-Host "‚ÑπÔ∏è $($k.ToUpper()): no changes detected"
              $flags[$k]=$false
              $counts[$k]=0
            }
          }

          if(-not ($flags.create -or $flags.alter -or $flags.drop)){
            Write-Host "::notice title=No changed SQL::Nothing to deploy."
          }
          
          Write-Host ""
          Write-Host "========================================="
          Write-Host "DEPLOYMENT DETECTION SUMMARY"
          Write-Host "========================================="
          Write-Host "CREATE: $($counts.create) files"
          Write-Host "ALTER:  $($counts.alter) files"
          Write-Host "DROP:   $($counts.drop) files"
          Write-Host "Range: $lastRef...$currentRef"
          Write-Host "========================================="

      - name: Expose outputs
        id: outvars
        shell: powershell
        run: |
          function HasList($f){ 
            if(!(Test-Path $f -PathType Leaf -ErrorAction SilentlyContinue)){ return $false }
            $content = Get-Content $f -ErrorAction SilentlyContinue
            return ($content -and $content.Count -gt 0)
          }
          
          $hasCreate = 'false'
          $createCount = 0
          if(HasList 'deploy\_changed_create.txt'){ 
            $hasCreate='true'
            $createCount = (Get-Content 'deploy\_changed_create.txt').Count
          }
          
          $hasAlter = 'false'
          $alterCount = 0
          if(HasList 'deploy\_changed_alter.txt'){ 
            $hasAlter='true'
            $alterCount = (Get-Content 'deploy\_changed_alter.txt').Count
          }
          
          $hasDrop = 'false'
          $dropCount = 0
          if(HasList 'deploy\_changed_drop.txt'){ 
            $hasDrop='true'
            $dropCount = (Get-Content 'deploy\_changed_drop.txt').Count
          }
          
          "has_create=$hasCreate" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "has_alter=$hasAlter"   | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "has_drop=$hasDrop"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "create_count=$createCount" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "alter_count=$alterCount"   | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "drop_count=$dropCount"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          
          Write-Host "Output flags:"
          Write-Host "  has_create=$hasCreate (count: $createCount)"
          Write-Host "  has_alter=$hasAlter (count: $alterCount)"
          Write-Host "  has_drop=$hasDrop (count: $dropCount)"

      - name: Upload change lists
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: prod-changed-sql-lists
          path: |
            deploy\_changed_*.txt
          if-no-files-found: ignore

  deploy_create_prod:
    needs: compute_changes
    if: needs.compute_changes.outputs.has_create == 'true' && needs.compute_changes.outputs.create_count != '0'
    runs-on: [self-hosted, Windows]
    environment: production
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_ref }}
      - uses: actions/download-artifact@v4
        with:
          name: prod-changed-sql-lists
          path: ./

      - name: Debug file structure
        shell: powershell
        run: |
          Write-Host "=== Current Directory Structure ==="
          Get-ChildItem -Recurse | Where-Object { $_.Name -like "*changed*" -or $_.Name -like "*create*" } | 
            Select-Object FullName, Length | Format-Table -AutoSize
          
          Write-Host "=== CREATE Files List ==="
          if (Test-Path 'deploy\_changed_create.txt') {
            $files = Get-Content 'deploy\_changed_create.txt'
            Write-Host "Files to deploy:"
            foreach ($file in $files) {
              Write-Host "  - $file"
              if (Test-Path $file) {
                Write-Host "    [FOUND]"
              } else {
                Write-Host "    [NOT FOUND - Searching...]"
                $found = Get-ChildItem -Recurse -Filter (Split-Path $file -Leaf) | Select-Object -First 1
                if ($found) {
                  Write-Host "    [FOUND AT] $($found.FullName)"
                }
              }
            }
          }

      - name: Use sqlcmd
        run: echo SQLCMD_EXE=${{ vars.SQLCMD_EXE }}>>%GITHUB_ENV%

      - name: Verify change list
        shell: powershell
        run: |
          if (!(Test-Path 'deploy\_changed_create.txt')) {
            Write-Host "::error::File not found!"
            exit 1
          }
          $content = Get-Content 'deploy\_changed_create.txt'
          if (!$content -or $content.Count -eq 0) {
            Write-Host "::error::File is empty!"
            exit 1
          }
          Write-Host "‚úÖ Found $($content.Count) file(s)"

      - name: Guard disallowed types (CREATE only)
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          if(!(Test-Path 'deploy\_changed_create.txt')){ exit 0 }
          $patMax    = '\b(?:n?varchar|varbinary)\s*\(\s*max\s*\)'
          $patLegacy = '\b(?:text|ntext|image)\b'
          $bad=$legacy=$null
          foreach($f in Get-Content 'deploy\_changed_create.txt'){
            if(Test-Path $f){
              $t=(Get-Content $f -Raw)
              if($t -match $patMax){ $bad += $f }
              if($t -match $patLegacy){ $legacy += $f }
            }
          }
          if($bad -or $legacy){
            Write-Host '‚ùå Disallowed in CREATE:'
            if($bad){ $bad|Sort-Object -Unique|ForEach-Object{ " - $_" } }
            if($legacy){ $legacy|Sort-Object -Unique|ForEach-Object{ " - $_" } }
            exit 1
          }
          Write-Host '‚úÖ CREATE type guard passed.'

      - name: Show files to deploy
        shell: powershell
        run: |
          Write-Host "Files to be deployed to PRODUCTION:"
          Get-Content 'deploy\_changed_create.txt' | ForEach-Object { 
            Write-Host "  üìÑ $_"
            if (Test-Path $_) {
              $size = (Get-Item $_).Length
              Write-Host "     Size: $size bytes"
            }
          }

      - name: Deploy CREATE (changed only) - FIXED
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
          D: ${{ secrets.PROD_DB_NAME }}
          U: ${{ secrets.PROD_DB_USER }}
          W: ${{ secrets.PROD_DB_PASSWORD }}
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          
          $PORT = $env:P
          if ([string]::IsNullOrWhiteSpace($PORT)) { $PORT = "1433" }
          
          if (!(Test-Path 'deploy\_changed_create.txt')) {
            Write-Error "No changed CREATE list found. Skipping."
            exit 1
          }
          
          $files = Get-Content 'deploy\_changed_create.txt' | Where-Object { $_.Trim() }
          if ($files.Count -eq 0) {
            Write-Error "No files found in _changed_create.txt"
            exit 1
          }
          
          $DEPLOYED = 0
          $FAILED = 0
          
          foreach ($file in $files) {
            $trimmedFile = $file.Trim()
            if ([string]::IsNullOrWhiteSpace($trimmedFile)) { continue }
            
            Write-Host ""
            Write-Host "====================================="
            Write-Host "[DEPLOY] CREATE: $trimmedFile"
            Write-Host "====================================="
            
            # Check if file exists with case sensitivity
            if (Test-Path $trimmedFile) {
              $fullPath = Resolve-Path $trimmedFile
              Write-Host "File found at: $fullPath"
              
              # Deploy using sqlcmd
              $sqlcmdArgs = @(
                "-S", "$env:H,$PORT",
                "-d", "$env:D", 
                "-U", "$env:U",
                "-P", "$env:W",
                "-b", "-C",
                "-i", "`"$fullPath`""
              )
              
              Write-Host "Executing: $env:SQLCMD_EXE $sqlcmdArgs"
              $process = Start-Process -FilePath $env:SQLCMD_EXE -ArgumentList $sqlcmdArgs -Wait -PassThru -NoNewWindow
              
              if ($process.ExitCode -eq 0) {
                Write-Host "[SUCCESS] $trimmedFile"
                $DEPLOYED++
              } else {
                Write-Host "[FAILED] $trimmedFile - Exit code: $($process.ExitCode)"
                $FAILED++
                exit 1
              }
            } else {
              Write-Host "[ERROR] File not found: $trimmedFile"
              Write-Host "Searching for similar files..."
              $similar = Get-ChildItem -Recurse -Filter (Split-Path $trimmedFile -Leaf) | Select-Object -First 1
              if ($similar) {
                Write-Host "Found similar file at: $($similar.FullName)"
              }
              $FAILED++
              exit 1
            }
          }
          
          Write-Host ""
          Write-Host "====================================="
          Write-Host "[SUMMARY] CREATE Deployment"
          Write-Host "====================================="
          Write-Host "Deployed: $DEPLOYED"
          Write-Host "Failed: $FAILED"
          Write-Host "====================================="
          
          if ($DEPLOYED -eq 0) {
            Write-Error "No files were deployed!"
            exit 1
          }

  # ALTER dan DROP jobs tetap sama seperti sebelumnya, tapi dengan PowerShell deployment
  deploy_alter_prod:
    needs: [compute_changes, deploy_create_prod]
    if: needs.compute_changes.outputs.has_alter == 'true' && needs.compute_changes.outputs.alter_count != '0'
    runs-on: [self-hosted, Windows]
    environment: production
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_ref }}
      - uses: actions/download-artifact@v4
        with:
          name: prod-changed-sql-lists
          path: ./

      - name: Use sqlcmd
        run: echo SQLCMD_EXE=${{ vars.SQLCMD_EXE }}>>%GITHUB_ENV%

      - name: Guard disallowed types (ALTER only)
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          if(!(Test-Path 'deploy\_changed_alter.txt')){ exit 0 }
          $patMax    = '\b(?:n?varchar|varbinary)\s*\(\s*max\s*\)'
          $patLegacy = '\b(?:text|ntext|image)\b'
          $bad=$legacy=$null
          foreach($f in Get-Content 'deploy\_changed_alter.txt'){
            if(Test-Path $f){
              $t=(Get-Content $f -Raw)
              if($t -match $patMax){ $bad += $f }
              if($t -match $patLegacy){ $legacy += $f }
            }
          }
          if($bad -or $legacy){
            Write-Host '‚ùå Disallowed in ALTER:'
            if($bad){ $bad|Sort-Object -Unique|ForEach-Object{ " - $_" } }
            if($legacy){ $legacy|Sort-Object -Unique|ForEach-Object{ " - $_" } }
            exit 1
          }
          Write-Host '‚úÖ ALTER type guard passed.'

      - name: Generate & run backup (ALTER)
        shell: powershell
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
          D: ${{ secrets.PROD_DB_NAME }}
          U: ${{ secrets.PROD_DB_USER }}
          W: ${{ secrets.PROD_DB_PASSWORD }}
        run: |
          $ErrorActionPreference='Stop'
          if(!(Test-Path 'deploy\_changed_alter.txt')){ exit 0 }
          $ts=Get-Date -Format yyyyMMddHHmmss
          $out="deploy\__auto_backup_alter_prod_$ts.sql"
          $rx=[regex]'(?is)\balter\s+table\s+(?:\[?(?<s>\w+)\]?\.)?\[?(?<t>\w+)\]?'
          $pairs=@()
          foreach($f in Get-Content 'deploy\_changed_alter.txt'){
            if(Test-Path $f){
              $c=Get-Content $f -Raw
              foreach($m in $rx.Matches($c)){
                $s = $m.Groups['s'].Success ? $m.Groups['s'].Value : 'dbo'
                $t = $m.Groups['t'].Value
                if($t){ $pairs += "$s.$t" }
              }
            }
          }
          $pairs=$pairs|Sort-Object -Unique
          if(-not $pairs){ Write-Host "No ALTER target tables. Skip backup."; exit 0 }
          $sb=New-Object Text.StringBuilder
          foreach($qn in $pairs){
            $schema,$table=$qn.Split('.')
            $bk="[$schema].[$table"+"__bak_$ts]"
            $qn2="[$schema].[$table]"
            [void]$sb.AppendLine("IF OBJECT_ID(N'$qn2','U') IS NOT NULL AND OBJECT_ID(N'$bk','U') IS NULL")
            [void]$sb.AppendLine("BEGIN SELECT * INTO $bk FROM $qn2 WITH (HOLDLOCK, TABLOCKX); END")
            [void]$sb.AppendLine("GO")
          }
          $sb.ToString() | Set-Content -Path $out -Encoding UTF8
          $port="${{ secrets.PROD_DB_PORT }}"; if([string]::IsNullOrWhiteSpace($port)){$port='1433'}
          & "$env:SQLCMD_EXE" -S "${{ secrets.PROD_DB_HOST }}",$port -d "${{ secrets.PROD_DB_NAME }}" -U "${{ secrets.PROD_DB_USER }}" -P "${{ secrets.PROD_DB_PASSWORD }}" -b -C -i $out

      - name: Deploy ALTER (changed only) - FIXED
        env:
          H: ${{ secrets.PROD_DB_HOST }}
          P: ${{ secrets.PROD_DB_PORT }}
          D: ${{ secrets.PROD_DB_NAME }}
          U: ${{ secrets.PROD_DB_USER }}
          W: ${{ secrets.PROD_DB_PASSWORD }}
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $PORT = $env:P
          if ([string]::IsNullOrWhiteSpace($PORT)) { $PORT = "1433" }
          $DEPLOYED = 0
          
          $files = Get-Content 'deploy\_changed_alter.txt' | Where-Object { $_.Trim() }
          foreach ($file in $files) {
            $trimmedFile = $file.Trim()
            if (Test-Path $trimmedFile) {
              Write-Host ""
              Write-Host "[DEPLOY] ALTER: $trimmedFile"
              $fullPath = Resolve-Path $trimmedFile
              
              $sqlcmdArgs = @(
                "-S", "$env:H,$PORT",
                "-d", "$env:D", 
                "-U", "$env:U",
                "-P", "$env:W",
                "-b", "-C",
                "-i", "`"$fullPath`""
              )
              
              Write-Host "Executing: $env:SQLCMD_EXE $sqlcmdArgs"
              $process = Start-Process -FilePath $env:SQLCMD_EXE -ArgumentList $sqlcmdArgs -Wait -PassThru -NoNewWindow
              
              if ($process.ExitCode -eq 0) {
                Write-Host "[SUCCESS] $trimmedFile"
                $DEPLOYED++
              } else {
                Write-Error "Failed to deploy: $trimmedFile"
                exit 1
              }
            } else {
              Write-Error "File not found: $trimmedFile"
              exit 1
            }
          }
          Write-Host "Deployed $DEPLOYED ALTER file(s)"

  create_prod_tag:
    if: ${{ success() }}
    needs: [deploy_create_prod, deploy_alter_prod, deploy_drop_prod]
    runs-on: [self-hosted, Windows]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Create production tag
        shell: powershell
        run: |
          $timestamp = Get-Date -Format "yyyyMMddHHmmss"
          $tagName = "prod-$timestamp"
          $commitMsg = "Production deployment $timestamp"
          if ('${{ github.event.inputs.note }}' -ne '') {
            $commitMsg += " - ${{ github.event.inputs.note }}"
          }
          
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git tag -a $tagName -m $commitMsg
          git push origin $tagName
          
          Write-Host "‚úÖ Created production tag: $tagName"

  upload_logs_prod:
    if: ${{ always() }}
    needs: [compute_changes, deploy_create_prod, deploy_alter_prod, deploy_drop_prod]
    runs-on: [self-hosted, Windows]
    steps:
      - uses: actions/checkout@v4
      - name: Upload deploy logs
        uses: actions/upload-artifact@v4
        with:
          name: production-deploy-logs
          path: |
            deploy_logs_prod/**
            deploy\__auto_backup_*.sql
          if-no-files-found: warn