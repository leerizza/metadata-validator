name: PR → Validate & Deploy to STAGING

on:
  pull_request:
    paths:
      - "deploy/**/*.sql"
      - "rules.yml"
      - ".github/**"

permissions:
  contents: read
  pull-requests: write
  issues: write

defaults:
  run:
    shell: powershell

jobs:
  validate_and_deploy:
    runs-on: [self-hosted, Windows]
    environment: staging

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve sqlcmd
        run: |
          $ErrorActionPreference='Stop'
          $sqlcmdPaths = @(
            "${{ vars.SQLCMD_EXE }}",
            "C:\Program Files\SqlCmd\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          )
          $sqlcmd = $sqlcmdPaths | Where-Object { $_ -and (Test-Path $_) } | Select-Object -First 1
          if (!$sqlcmd) { try { $sqlcmd = (where.exe sqlcmd 2>$null) } catch {} }
          if (!$sqlcmd) { throw "sqlcmd.exe not found" }
          Write-Host "Using sqlcmd: $sqlcmd"
          Add-Content -Path $env:GITHUB_ENV -Value "SQLCMD_EXE=$sqlcmd"

      - name: Test database connection
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          $ErrorActionPreference='Stop'
          $PORT = if ($env:P) { $env:P } else { "1433" }
          Write-Host "Testing connection to $env:H,$PORT..."
          $ok = Test-NetConnection -ComputerName $env:H -Port $PORT -InformationLevel Quiet -WarningAction SilentlyContinue
          if (!$ok) { throw "Cannot reach database host" }
          & $env:SQLCMD_EXE -S "$env:H,$PORT" -d $env:D -U $env:U -P $env:W -l 10 -b -C -Q "SELECT 1"
          if ($LASTEXITCODE -ne 0) { throw "Database login failed" }
          Write-Host "✅ Database connection successful"

      - name: Detect changed projects
        id: detect_projects
        run: |
          $ErrorActionPreference='Stop'
          git config --global --add safe.directory "$env:GITHUB_WORKSPACE" 2>$null
          try { git fetch origin --depth=100 2>$null; git fetch --all --tags --prune 2>$null } catch {}

          $base = '${{ github.base_ref }}'
          if ($base) {
            try { git fetch origin "${base}:refs/remotes/origin/$base" --depth=100 2>$null } catch {}
            $range = "origin/$base...HEAD"
          } else {
            $before = '${{ github.event.before }}'
            if ([string]::IsNullOrWhiteSpace($before) -or $before -match '^0+$') { $range = 'HEAD~1...HEAD' } else { $range = "$before...HEAD" }
          }
          Write-Host ('Git diff range: ' + $range)

          $changedFiles   = git -c core.quotepath=false diff --name-only --diff-filter=AMR $range -- "deploy/**/*.sql" 2>$null
          $untrackedFiles = git ls-files -mo --exclude-standard -- "deploy/**/*.sql" 2>$null

          $allFiles = @()
          if ($changedFiles) { $allFiles += $changedFiles }
          if ($untrackedFiles) { $allFiles += $untrackedFiles }
          $allFiles = $allFiles | Where-Object { $_ -and (Test-Path $_) } | Sort-Object -Unique

          if ($allFiles.Count -eq 0) {
            Write-Host 'No SQL files changed in deploy/.'
            Add-Content -Path $env:GITHUB_OUTPUT -Value 'projects='
            Add-Content -Path $env:GITHUB_OUTPUT -Value 'has_changes=false'
            exit 0
          }

          $projects = @{}
          foreach ($file in $allFiles) {
            if ($file -match '^deploy/([^/]+)/') {
              $proj = $Matches[1]
              if (-not $projects.ContainsKey($proj)) { $projects[$proj] = @() }
              $projects[$proj] += $file
            }
          }

          Write-Host ''
          Write-Host '========================================='
          Write-Host 'CHANGED PROJECTS DETECTED'
          Write-Host '========================================='
          foreach ($p in $projects.Keys | Sort-Object) {
            Write-Host ('- ' + $p + ' (' + ($projects[$p].Count) + ' files)')
            $projects[$p] | Sort-Object | ForEach-Object { Write-Host ('   - ' + $_) }
          }
          Write-Host '========================================='

          $projectList = ($projects.Keys | Sort-Object) -join ','
          Add-Content -Path $env:GITHUB_OUTPUT -Value ('projects=' + $projectList)
          Add-Content -Path $env:GITHUB_OUTPUT -Value 'has_changes=true'

          foreach ($p in $projects.Keys) {
            $projects[$p] | Set-Content ('_changed_' + $p + '.txt') -Encoding UTF8
          }

      - name: Load validation rules (pure PowerShell, no Node/npm)
        id: load_rules
        if: steps.detect_projects.outputs.has_changes == 'true'
        run: |
          $ErrorActionPreference='Stop'
          if (-not (Test-Path "rules.yml")) {
            Write-Host "⚠️ rules.yml not found, using basic validation"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "rules_loaded=false"
            exit 0
          }

          function Convert-Scalar($s) {
            if ($null -eq $s) { return "" }
            $t = $s.Trim()
            if ($t -match '^(?i:true|false)$') { return [bool]::Parse($t) }
            if ($t -match '^-?\d+(\.\d+)?$')   { return [double]$t }
            return $t.Trim("'`"")
          }

          # FIX: read once with -Raw, then split manually (no -Delimiter)
          $text  = Get-Content "rules.yml" -Raw -Encoding UTF8 -ErrorAction Stop
          $lines = $text -split "\r?\n"

          $root  = [ordered]@{}
          $stack = New-Object System.Collections.Stack
          $stack.Push(@{ indent = -1; node = $root; key = $null; container = $null })

          foreach ($raw in $lines) {
            if ($null -eq $raw) { continue }
            $trim = $raw.Trim()
            if ($trim -eq "" -or $trim.StartsWith("#")) { continue }

            $indent = ([regex]::Match($raw, '^( *)')).Groups[1].Value.Length
            while ($stack.Count -gt 0 -and $indent -le $stack.Peek().indent) { [void]$stack.Pop() }
            $parent = $stack.Peek()

            if ($trim.StartsWith("- ")) {
              $rest = $trim.Substring(2).Trim()
              if (-not ($parent.node -is [System.Collections.IList])) {
                if ($null -ne $parent.key -and $null -ne $parent.container) {
                  $parent.container[$parent.key] = New-Object System.Collections.ArrayList
                  $parent.node = $parent.container[$parent.key]
                } else {
                  $a = New-Object System.Collections.ArrayList
                  $parent.node = $a
                }
              }
              if ($rest -match '^\s*([^:]+)\s*:\s*(.+)$') {
                $item = [ordered]@{}
                $item[$Matches[1].Trim()] = Convert-Scalar $Matches[2]
              } elseif ($rest.Length -gt 0) {
                $item = Convert-Scalar $rest
              } else {
                $item = [ordered]@{}
              }
              [void]$parent.node.Add($item)
              if ($item -is [hashtable]) {
                $stack.Push(@{ indent = $indent; node = $item; key = $null; container = $parent.node })
              }
              continue
            }

            $kv = $trim -split ":", 2
            if ($kv.Count -lt 2) { continue }
            $key = $kv[0].Trim(" `"`'")
            $val = $kv[1].Trim()

            if ($parent.node -is [System.Collections.IList]) {
              $last = $parent.node[$parent.node.Count-1]
              if (-not ($last -is [hashtable])) {
                $last = [ordered]@{}
                [void]$parent.node.Add($last)
              }
              if ($val -eq "") {
                $last[$key] = [ordered]@{}
                $stack.Push(@{ indent = $indent; node = $last[$key]; key = $key; container = $last })
              } else {
                $last[$key] = Convert-Scalar $val
              }
            } else {
              if ($val -eq "") {
                $parent.node[$key] = [ordered]@{}
                $stack.Push(@{ indent = $indent; node = $parent.node[$key]; key = $key; container = $parent.node })
              } else {
                $parent.node[$key] = Convert-Scalar $val
              }
            }
          }

          function As-Array($v) {
            if ($null -eq $v) { return @() }
            if ($v -is [System.Collections.IList]) { return $v }
            return @($v)
          }
          function Get-Path($obj, [string]$path, $default=$null) {
            $cur = $obj
            foreach ($p in $path -split '\.') {
              if ($null -eq $cur) { return $default }
              if ($cur -is [System.Collections.IDictionary]) {
                if (-not $cur.Contains($p)) { return $default }
                $cur = $cur[$p]
              } else { return $default }
            }
            if ($null -eq $cur) { return $default } else { return $cur }
          }

          $normalized = [ordered]@{
            type_guards = @{
              create = @{
                enabled = [bool](Get-Path $root 'type_guards.create.enabled' $false)
                rules   = As-Array (Get-Path $root 'type_guards.create.disallowed_patterns' @())
              }
              alter = @{
                enabled = [bool](Get-Path $root 'type_guards.alter.enabled' $false)
                rules   = As-Array (Get-Path $root 'type_guards.alter.disallowed_patterns' @())
              }
              drop = @{
                enabled = [bool](Get-Path $root 'type_guards.drop.enabled' $false)
                rules   = @()
              }
            }
            naming_conventions = @{
              enabled = [bool](Get-Path $root 'naming_conventions.enabled' $false)
              tables  = @{
                pattern = "" + (Get-Path $root 'naming_conventions.tables.pattern' "")
                message = "" + (Get-Path $root 'naming_conventions.tables.message' "")
              }
              columns = @{
                pattern = "" + (Get-Path $root 'naming_conventions.columns.pattern' "")
                message = "" + (Get-Path $root 'naming_conventions.columns.message' "")
              }
            }
            performance_checks = @{
              enabled = [bool](Get-Path $root 'performance_checks.enabled' $false)
              rules   = As-Array (Get-Path $root 'performance_checks.rules' @())
            }
            security_checks = @{
              enabled = [bool](Get-Path $root 'security_checks.enabled' $false)
              rules   = As-Array (Get-Path $root 'security_checks.rules' @())
            }
            data_integrity = @{
              enabled = [bool](Get-Path $root 'data_integrity.enabled' $false)
              rules   = As-Array (Get-Path $root 'data_integrity.rules' @())
            }
            code_quality = @{
              enabled = [bool](Get-Path $root 'code_quality.enabled' $false)
              rules   = As-Array (Get-Path $root 'code_quality.rules' @())
            }
            custom_rules = @{
              enabled = [bool](Get-Path $root 'custom_rules.enabled' $false)
              rules   = As-Array (Get-Path $root 'custom_rules.rules' @())
            }
            deployment_safety = @{
              enabled = [bool](Get-Path $root 'deployment_safety.enabled' $true)
              rules   = As-Array (Get-Path $root 'deployment_safety.rules' @())
            }
          }

          ($normalized | ConvertTo-Json -Depth 50) | Set-Content "_validation_rules.json" -Encoding UTF8
          Write-Host "✅ rules.yml parsed (pure PowerShell) → _validation_rules.json"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "rules_loaded=true"


      - name: Validate SQL files
        if: steps.detect_projects.outputs.has_changes == 'true'
        run: |
          $ErrorActionPreference='Stop'
          Write-Host ''
          Write-Host '========================================='
          Write-Host 'VALIDATING SQL FILES'
          Write-Host '========================================='

          if (!(Test-Path '_validation_rules.json')) {
            Write-Host 'Rules not loaded; basic validation only'
            $rules = $null
          } else {
            $rules = Get-Content '_validation_rules.json' | ConvertFrom-Json
          }

          Add-Type -AssemblyName 'System.Core' | Out-Null
          $ROpts = [System.Text.RegularExpressions.RegexOptions]::IgnoreCase -bor `
                   [System.Text.RegularExpressions.RegexOptions]::Singleline -bor `
                   [System.Text.RegularExpressions.RegexOptions]::Multiline
          function Test-Pat([string]$s,[string]$p){ if([string]::IsNullOrEmpty($p)){ $false } else { [regex]::IsMatch($s,$p,$ROpts) } }
          function Last-Line([string]$s){ ($s -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' } | Select-Object -Last 1) }

          $projects = '${{ steps.detect_projects.outputs.projects }}'.Split(',') | Where-Object { $_ }
          $validationFailed = $false
          $totalErrors = 0
          $totalWarnings = 0

          foreach ($proj in $projects) {
            $fileList = '_changed_' + $proj + '.txt'
            if (!(Test-Path $fileList)) { continue }
            Write-Host ''
            Write-Host ('Validating project: ' + $proj)
            $files = Get-Content $fileList
            foreach ($file in $files) {
              $file = $file.Trim()
              if (!(Test-Path $file)) { continue }
              $content = Get-Content $file -Raw
              Write-Host ('  Checking: ' + $file)

              $errors = @()
              $warnings = @()

              $isCreate = Test-Pat $content '\bCREATE\s+(TABLE|PROCEDURE|FUNCTION|VIEW)\b'
              $isAlter  = Test-Pat $content '\bALTER\s+(TABLE|PROCEDURE|FUNCTION|VIEW)\b'

              if ($rules) {
                # --- TYPE GUARDS: CREATE ---
                if ($rules.type_guards.create.enabled -and $isCreate) {
                  foreach ($r in $rules.type_guards.create.rules) {
                    if ($r.pattern -and (Test-Pat $content ([string]$r.pattern))) {
                      if ($r.severity -eq 'error') { $errors += ($r.name + ': ' + $r.message) } else { $warnings += ($r.name + ': ' + $r.message) }
                    }
                  }
                }
                # --- TYPE GUARDS: ALTER ---
                if ($rules.type_guards.alter.enabled -and $isAlter) {
                  # normal content
                  foreach ($r in $rules.type_guards.alter.rules) {
                    if ($r.pattern -and (Test-Pat $content ([string]$r.pattern))) {
                      if ($r.severity -eq 'error') { $errors += ($r.name + ': ' + $r.message) } else { $warnings += ($r.name + ': ' + $r.message) }
                    } else {
                      # coba lagi di konten yang dinormalisasi (semua whitespace → 1 spasi)
                      $contentNorm = ($content -replace '\s+', ' ')
                      if ($r.pattern -and (Test-Pat $contentNorm ([string]$r.pattern))) {
                        if ($r.severity -eq 'error') { $errors += ($r.name + ': ' + $r.message) } else { $warnings += ($r.name + ': ' + $r.message) }
                      }
                    }
                  }

                  # --- SAFETY NET: blok MAX types apapun polanya ---
                  $contentNorm = ($content -replace '\s+', ' ')
                  if (Test-Pat $contentNorm '\b(?:n?varchar|varbinary)\s*\(\s*max\s*\)') {
                    $errors += 'MAX data types in ALTER are not allowed (VARCHAR(MAX)/NVARCHAR(MAX)/VARBINARY(MAX))'
                  }
                }

                # --- NAMING ---
                if ($rules.naming_conventions.enabled) {
                  if ($isCreate -and $rules.naming_conventions.tables.pattern) {
                    if ($content -match '(?i)CREATE\s+TABLE\s+(?:\[?([a-zA-Z0-9_]+)\]?\.)?\[?([a-zA-Z0-9_]+)\]?') {
                      $tableName = $Matches[2]
                      if (-not (Test-Pat $tableName $rules.naming_conventions.tables.pattern)) {
                        $warnings += ('Table naming: ' + $rules.naming_conventions.tables.message + ' (found: ' + $tableName + ')')
                      }
                    }
                  }
                  if ($rules.naming_conventions.columns.pattern) {
                    $colMatches = [regex]::Matches($content,'(?i)(?:ADD|ALTER\s+COLUMN)\s+\[?([a-zA-Z0-9_]+)\]?\s+',$ROpts)
                    foreach ($m in $colMatches) {
                      $c = $m.Groups[1].Value
                      if (-not (Test-Pat $c $rules.naming_conventions.columns.pattern)) {
                        $warnings += ('Column naming: ' + $rules.naming_conventions.columns.message + ' (found: ' + $c + ')')
                      }
                    }
                  }
                }

                # --- GENERIC CATEGORY RUNNER ---
                function Apply-Rules($enabled,$list,[string]$contentRef){
                  if(-not $enabled){ return ,(@(),@()) }
                  $errs=@(); $warns=@()
                  foreach($r in $list){
                    $pat = '' + $r.pattern
                    if([string]::IsNullOrEmpty($pat)){ continue }
                    if(Test-Pat $contentRef $pat){
                      if($r.severity -eq 'error'){ $errs += ($r.name + ': ' + $r.message) } else { $warns += ($r.name + ': ' + $r.message) }
                    }
                  }
                  return ,($errs,$warns)
                }

                $res = Apply-Rules $rules.performance_checks.enabled $rules.performance_checks.rules $content
                $errors += $res[0]; $warnings += $res[1]
                $res = Apply-Rules $rules.security_checks.enabled $rules.security_checks.rules $content
                $errors += $res[0]; $warnings += $res[1]
                $res = Apply-Rules $rules.data_integrity.enabled $rules.data_integrity.rules $content
                $errors += $res[0]; $warnings += $res[1]
                $res = Apply-Rules $rules.code_quality.enabled $rules.code_quality.rules $content
                $errors += $res[0]; $warnings += $res[1]
                $res = Apply-Rules $rules.custom_rules.enabled $rules.custom_rules.rules $content
                $errors += $res[0]; $warnings += $res[1]

                # --- DEPLOYMENT SAFETY ---
                if ($rules.deployment_safety.enabled) {
                  foreach ($r in $rules.deployment_safety.rules) {
                    if ($r.name -eq 'Missing GO terminator') {
                      $last = Last-Line $content
                      if (($last -ne $null) -and ($last.ToUpper() -ne 'GO')) {
                        if ($r.severity -eq 'error') { $errors += $r.message } else { $warnings += $r.message }
                      }
                    } elseif ($r.pattern -and (Test-Pat $content ([string]$r.pattern))) {
                      if ($r.severity -eq 'error') { $errors += ($r.name + ': ' + $r.message) } else { $warnings += ($r.name + ': ' + $r.message) }
                    }
                  }
                }
              } else {
                # Fallback minimal checks
                if (Test-Pat $content '\bDROP\s+DATABASE\b') { $errors += 'DROP DATABASE detected (CRITICAL - not allowed)' }
                if (Test-Pat $content '\bTRUNCATE\s+TABLE\b') { $errors += 'TRUNCATE TABLE detected (data loss risk)' }
                if (Test-Pat $content '\bDROP\s+TABLE\b')     { $warnings += 'DROP TABLE detected' }
                $last = Last-Line $content
                if (($last -ne $null) -and ($last.ToUpper() -ne 'GO')) { $errors += 'SQL file must end with GO statement' }
              }

              foreach ($w in $warnings) { Write-Host ('    WARNING: ' + $w) -ForegroundColor Yellow; $totalWarnings++ }
              if ($errors.Count -gt 0) {
                Write-Host '    Validation FAILED' -ForegroundColor Red
                foreach ($e in $errors) { Write-Host ('       - ' + $e) -ForegroundColor Red; $totalErrors++ }
                $validationFailed = $true
              } else {
                Write-Host '    Validation PASSED' -ForegroundColor Green
              }
            }
          }

          Write-Host ''
          Write-Host '========================================='
          Write-Host 'VALIDATION SUMMARY'
          Write-Host '========================================='
          Write-Host ('Total errors: ' + $totalErrors)
          Write-Host ('Total warnings: ' + $totalWarnings)
          if ($validationFailed) { Write-Host 'Status: FAILED' -ForegroundColor Red; Write-Host '========================================='; throw 'Validation failed' }
          Write-Host 'Status: PASSED' -ForegroundColor Green
          Write-Host '========================================='


      - name: Deploy to STAGING (per project)
        if: steps.detect_projects.outputs.has_changes == 'true'
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          $ErrorActionPreference='Stop'
          $PORT = if ($env:P) { $env:P } else { '1433' }

          Write-Host ''
          Write-Host '========================================='
          Write-Host 'DEPLOYING TO STAGING'
          Write-Host '========================================='

          $projects = '${{ steps.detect_projects.outputs.projects }}'.Split(',') | Where-Object { $_ }
          $totalDeployed = 0
          $deploymentLog = @()

          foreach ($proj in $projects) {
            Write-Host ''
            Write-Host ('Deploying project: ' + $proj)
            Write-Host '-----------------------------------------'
            $fileList = '_changed_' + $proj + '.txt'
            if (!(Test-Path $fileList)) { Write-Host '  No file list found, skipping'; continue }

            $files = Get-Content $fileList | Sort-Object
            $hasAlter = $false
            foreach ($f in $files) { if ((Get-Content $f -Raw) -match '(?i)\bALTER\s+TABLE\b') { $hasAlter = $true; break } }
            if ($hasAlter) { Write-Host '  Project contains ALTER - create backup here if needed' -ForegroundColor Yellow }

            foreach ($file in $files) {
              $file = $file.Trim()
              if (!(Test-Path $file)) { Write-Host ('  File not found: ' + $file) -ForegroundColor Red; throw ('Deployment failed: file not found ' + $file) }
              $fileName = Split-Path $file -Leaf
              Write-Host ('  Deploying: ' + $fileName)

              $fullPath = Resolve-Path $file
              $args = @('-S', ("{0},{1}" -f $env:H, $PORT), '-d', $env:D, '-U', $env:U, '-P', $env:W, '-b', '-C', '-i', $fullPath)

              & $env:SQLCMD_EXE @args
              if ($LASTEXITCODE -ne 0) {
                Write-Host ('  FAILED: ' + $fileName + ' (exit ' + $LASTEXITCODE + ')') -ForegroundColor Red
                throw ('Deployment failed for ' + $fileName)
              }

              Write-Host ('  SUCCESS: ' + $fileName) -ForegroundColor Green
              $totalDeployed++
              $deploymentLog += @{ project=$proj; file=$fileName; status='success'; timestamp=(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') }
            }

            $countProj = (($deploymentLog | Where-Object { $_.project -eq $proj }).Count)
            Write-Host ('  Project "' + $proj + '": deployed ' + $countProj + ' file(s)')
          }

          Write-Host ''
          Write-Host '========================================='
          Write-Host 'DEPLOYMENT SUMMARY'
          Write-Host '========================================='
          Write-Host ('Total projects: ' + $projects.Count)
          Write-Host ('Total files deployed: ' + $totalDeployed)
          Write-Host 'Status: SUCCESS'
          Write-Host '========================================='

          $deploymentLog | ConvertTo-Json | Set-Content 'deployment_log.json' -Encoding UTF8


      - name: Upload deployment artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: staging-deployment-logs
          path: |
            _changed_*.txt
            _validation_rules.json
            deployment_log.json
          if-no-files-found: ignore

      - name: Comment on PR
        if: always() && steps.detect_projects.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const projects = '${{ steps.detect_projects.outputs.projects }}'.split(',').filter(Boolean);
            let status = '${{ job.status }}' === 'success' ? '✅ SUCCESS' : '❌ FAILED';
            let comment = '## 🚀 Staging Deployment Report\n\n';
            comment += `**Status:** ${status}\n`;
            comment += `**Environment:** STAGING\n`;
            comment += `**Projects deployed:** ${projects.length}\n\n`;
            comment += '### 📁 Projects\n\n';
            for (const proj of projects) {
              comment += `#### ${proj}\n\n`;
              const fileList = `_changed_${proj}.txt`;
              if (fs.existsSync(fileList)) {
                const files = fs.readFileSync(fileList, 'utf8').trim().split('\n').filter(Boolean);
                comment += '| File | Status |\n|------|--------|\n';
                for (const f of files) {
                  const fileName = f.split('/').pop();
                  const icon = '${{ job.status }}' === 'success' ? '✅' : '❌';
                  comment += `| \`${fileName}\` | ${icon} |\n`;
                }
                comment += '\n';
              }
            }
            comment += '\n---\n';
            comment += `_Deployed at ${new Date().toISOString()}_`;
            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } catch (e) {
              core.warning(`Skipping PR comment: ${e.message}`);
            }
