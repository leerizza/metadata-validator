name: PR ‚Üí Validate & Deploy to STAGING

on:
  pull_request:
    paths:
      - "deploy/**/*.sql"
      - "rules.yml"
      - ".github/**"

defaults:
  run:
    shell: powershell

jobs:
  validate_and_deploy:
    runs-on: [self-hosted, Windows]
    environment: staging
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve sqlcmd
        run: |
          $ErrorActionPreference='Stop'
          $sqlcmdPaths = @(
            "${{ vars.SQLCMD_EXE }}",
            "C:\Program Files\SqlCmd\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          )
          $sqlcmd = $sqlcmdPaths | Where-Object { $_ -and (Test-Path $_) } | Select-Object -First 1
          if (!$sqlcmd) {
            try { $sqlcmd = (where.exe sqlcmd 2>$null) } catch {}
          }
          if (!$sqlcmd) { throw "sqlcmd.exe not found" }
          Write-Host "Using sqlcmd: $sqlcmd"
          "SQLCMD_EXE=$sqlcmd" | Out-File $env:GITHUB_ENV -Append

      - name: Test database connection
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          $PORT = if ($env:P) { $env:P } else { "1433" }
          Write-Host "Testing connection to $env:H,$PORT..."
          
          $result = Test-NetConnection -ComputerName $env:H -Port $PORT -InformationLevel Quiet -WarningAction SilentlyContinue
          if (!$result) { throw "Cannot reach database host" }
          
          & $env:SQLCMD_EXE -S "$env:H,$PORT" -d $env:D -U $env:U -P $env:W -l 10 -b -C -Q "SELECT 1"
          if ($LASTEXITCODE -ne 0) { throw "Database login failed" }
          Write-Host "‚úÖ Database connection successful"

      - name: Detect changed projects
        id: detect_projects
        run: |
          $ErrorActionPreference='Stop'
          git config --global --add safe.directory "$env:GITHUB_WORKSPACE" 2>$null
          
          try {
            git fetch origin --depth=100 2>$null
            git fetch --all --tags --prune 2>$null
          } catch {}
          
          $base = '${{ github.base_ref }}'
          if ($base) {
            try {
              git fetch origin "${base}:refs/remotes/origin/$base" --depth=100 2>$null
            } catch {}
            $range = "origin/$base...HEAD"
          } else {
            $before = '${{ github.event.before }}'
            if ([string]::IsNullOrWhiteSpace($before) -or $before -match '^0+$') {
              $range = 'HEAD~1...HEAD'
            } else {
              $range = "$before...HEAD"
            }
          }
          
          Write-Host "Git diff range: $range"
          
          # Get all changed SQL files in deploy/
          $changedFiles = git -c core.quotepath=false diff --name-only --diff-filter=AMR $range -- "deploy/**/*.sql" 2>$null
          $untrackedFiles = git ls-files -mo --exclude-standard -- "deploy/**/*.sql" 2>$null
          
          $allFiles = @()
          if ($changedFiles) { $allFiles += $changedFiles }
          if ($untrackedFiles) { $allFiles += $untrackedFiles }
          $allFiles = $allFiles | Where-Object { $_ -and (Test-Path $_) } | Sort-Object -Unique
          
          if ($allFiles.Count -eq 0) {
            Write-Host "‚ÑπÔ∏è No SQL files changed in deploy/"
            "projects=" | Out-File $env:GITHUB_OUTPUT -Append
            "has_changes=false" | Out-File $env:GITHUB_OUTPUT -Append
            exit 0
          }
          
          # Group files by project folder
          $projects = @{}
          foreach ($file in $allFiles) {
            # Extract project folder: deploy/project_name/file.sql
            if ($file -match '^deploy/([^/]+)/') {
              $projectName = $matches[1]
              if (!$projects.ContainsKey($projectName)) {
                $projects[$projectName] = @()
              }
              $projects[$projectName] += $file
            }
          }
          
          Write-Host ""
          Write-Host "========================================="
          Write-Host "CHANGED PROJECTS DETECTED"
          Write-Host "========================================="
          foreach ($proj in $projects.Keys | Sort-Object) {
            Write-Host "üìÅ $proj ($($projects[$proj].Count) files)"
            $projects[$proj] | Sort-Object | ForEach-Object { Write-Host "   - $_" }
          }
          Write-Host "========================================="
          
          # Save project list to output and file
          $projectList = ($projects.Keys | Sort-Object) -join ','
          "projects=$projectList" | Out-File $env:GITHUB_OUTPUT -Append
          "has_changes=true" | Out-File $env:GITHUB_OUTPUT -Append
          
          # Save detailed file list per project
          foreach ($proj in $projects.Keys) {
            $projects[$proj] | Set-Content "_changed_${proj}.txt" -Encoding UTF8
          }

      - name: Load validation rules
        id: load_rules
        if: steps.detect_projects.outputs.has_changes == 'true'
        run: |
          $ErrorActionPreference='Stop'
          
          if (!(Test-Path "rules.yml")) {
            Write-Host "‚ö†Ô∏è rules.yml not found, using default rules"
            "rules_loaded=false" | Out-File $env:GITHUB_OUTPUT -Append
            exit 0
          }
          
          Write-Host "üìã Loading validation rules from rules.yml..."
          
          # Read and parse YAML content
          $rulesContent = Get-Content "rules.yml" -Raw
          
          # Helper function to parse YAML patterns
          function Parse-PatternBlock {
            param($yamlBlock, $indent = 6)
            
            $patterns = @()
            $currentPattern = $null
            
            $lines = $yamlBlock -split "`n"
            foreach ($line in $lines) {
              if ($line -match "^\s{$indent}- pattern:\s*['""](.+?)['""]") {
                if ($currentPattern) { $patterns += $currentPattern }
                $currentPattern = @{
                  pattern = $matches[1]
                  name = ""
                  message = ""
                  severity = "error"
                }
              }
              elseif ($currentPattern) {
                if ($line -match "^\s+name:\s*['""](.+?)['""]") {
                  $currentPattern.name = $matches[1]
                }
                elseif ($line -match "^\s+message:\s*['""](.+?)['""]") {
                  $currentPattern.message = $matches[1]
                }
                elseif ($line -match "^\s+severity:\s*(\w+)") {
                  $currentPattern.severity = $matches[1]
                }
              }
            }
            if ($currentPattern) { $patterns += $currentPattern }
            return $patterns
          }
          
          # Parse type_guards for CREATE
          $createRules = @()
          if ($rulesContent -match '(?ms)type_guards:\s*\n\s*create:\s*\n\s*enabled:\s*true.*?\n\s*disallowed_patterns:\s*\n(.*?)(?=\n\s+alter:|\z)') {
            $createBlock = $matches[1]
            $createRules = Parse-PatternBlock $createBlock
          }
          
          # Parse type_guards for ALTER
          $alterRules = @()
          if ($rulesContent -match '(?ms)type_guards:\s*\n.*?\n\s*alter:\s*\n\s*enabled:\s*true.*?\n\s*disallowed_patterns:\s*\n(.*?)(?=\n\s+drop:|\z)') {
            $alterBlock = $matches[1]
            $alterRules = Parse-PatternBlock $alterBlock
          }
          
          # Parse naming_conventions
          $namingEnabled = $false
          if ($rulesContent -match '(?m)^naming_conventions:\s*\n\s*enabled:\s*true') {
            $namingEnabled = $true
          }
          
          $tableNamePattern = ""
          $tableNameMessage = ""
          if ($rulesContent -match "(?ms)tables:\s*\n\s*pattern:\s*['""](.+?)['""]\s*\n\s*message:\s*['""](.+?)['""]") {
            $tableNamePattern = $matches[1]
            $tableNameMessage = $matches[2]
          }
          
          $columnNamePattern = ""
          $columnNameMessage = ""
          if ($rulesContent -match "(?ms)columns:\s*\n\s*pattern:\s*['""](.+?)['""]\s*\n\s*message:\s*['""](.+?)['""]") {
            $columnNamePattern = $matches[1]
            $columnNameMessage = $matches[2]
          }
          
          # Parse performance_checks
          $performanceEnabled = $false
          if ($rulesContent -match '(?m)^performance_checks:\s*\n\s*enabled:\s*true') {
            $performanceEnabled = $true
          }
          
          # Parse security_checks
          $securityEnabled = $false
          if ($rulesContent -match '(?m)^security_checks:\s*\n\s*enabled:\s*true') {
            $securityEnabled = $true
          }
          
          # Build rules object
          $rules = @{
            type_guards = @{
              create = @{
                enabled = ($createRules.Count -gt 0)
                patterns = $createRules
              }
              alter = @{
                enabled = ($alterRules.Count -gt 0)
                patterns = $alterRules
              }
            }
            naming_conventions = @{
              enabled = $namingEnabled
              table_pattern = $tableNamePattern
              table_message = $tableNameMessage
              column_pattern = $columnNamePattern
              column_message = $columnNameMessage
            }
            performance_checks = @{
              enabled = $performanceEnabled
            }
            security_checks = @{
              enabled = $securityEnabled
            }
          }
          
          Write-Host "‚úÖ Loaded rules:"
          Write-Host "   - CREATE rules: $($createRules.Count) patterns"
          Write-Host "   - ALTER rules: $($alterRules.Count) patterns"
          Write-Host "   - Naming conventions: $(if($namingEnabled){'enabled'}else{'disabled'})"
          Write-Host "   - Performance checks: $(if($performanceEnabled){'enabled'}else{'disabled'})"
          Write-Host "   - Security checks: $(if($securityEnabled){'enabled'}else{'disabled'})"
          
          # Save rules to file for next step
          $rules | ConvertTo-Json -Depth 10 | Set-Content "_validation_rules.json"
          "rules_loaded=true" | Out-File $env:GITHUB_OUTPUT -Append

      - name: Validate SQL files
        if: steps.detect_projects.outputs.has_changes == 'true'
        run: |
          $ErrorActionPreference='Stop'
          
          Write-Host ""
          Write-Host "========================================="
          Write-Host "VALIDATING SQL FILES"
          Write-Host "========================================="
          
          # Load rules
          $rules = $null
          if (Test-Path "_validation_rules.json") {
            $rules = Get-Content "_validation_rules.json" | ConvertFrom-Json
          }
          
          $projects = '${{ steps.detect_projects.outputs.projects }}'.Split(',') | Where-Object { $_ }
          $validationFailed = $false
          $totalErrors = 0
          $totalWarnings = 0
          
          foreach ($proj in $projects) {
            $fileList = "_changed_${proj}.txt"
            if (!(Test-Path $fileList)) { continue }
            
            Write-Host ""
            Write-Host "üìÅ Validating project: $proj"
            
            $files = Get-Content $fileList
            foreach ($file in $files) {
              $file = $file.Trim()
              if (!(Test-Path $file)) { continue }
              
              Write-Host "  Checking: $file"
              
              $content = Get-Content $file -Raw
              $errors = @()
              $warnings = @()
              
              # Detect SQL operation type
              $isCreate = $content -match '(?i)\bCREATE\s+(TABLE|PROCEDURE|FUNCTION|VIEW)'
              $isAlter = $content -match '(?i)\bALTER\s+(TABLE|PROCEDURE|FUNCTION|VIEW)'
              $isDrop = $content -match '(?i)\bDROP\s+(TABLE|PROCEDURE|FUNCTION|VIEW)'
              
              if ($rules) {
                # Apply CREATE rules
                if ($isCreate -and $rules.type_guards.create.enabled) {
                  foreach ($rule in $rules.type_guards.create.patterns) {
                    if ($content -match $rule.pattern) {
                      $msg = "$($rule.name): $($rule.message)"
                      if ($rule.severity -eq "error") {
                        $errors += $msg
                      } else {
                        $warnings += $msg
                      }
                    }
                  }
                }
                
                # Apply ALTER rules
                if ($isAlter -and $rules.type_guards.alter.enabled) {
                  foreach ($rule in $rules.type_guards.alter.patterns) {
                    if ($content -match $rule.pattern) {
                      $msg = "$($rule.name): $($rule.message)"
                      if ($rule.severity -eq "error") {
                        $errors += $msg
                      } else {
                        $warnings += $msg
                      }
                    }
                  }
                }
                
                # Apply naming conventions
                if ($rules.naming_conventions.enabled) {
                  # Check table names
                  if ($isCreate -and $rules.naming_conventions.table_pattern) {
                    if ($content -match '(?i)CREATE\s+TABLE\s+(?:\[?dbo\]?\.)?\[?(\w+)\]?') {
                      $tableName = $matches[1]
                      if ($tableName -notmatch $rules.naming_conventions.table_pattern) {
                        $warnings += "Table naming: $($rules.naming_conventions.table_message) (found: $tableName)"
                      }
                    }
                  }
                  
                  # Check column names
                  if ($rules.naming_conventions.column_pattern) {
                    $columnMatches = [regex]::Matches($content, '(?i)(?:ADD|ALTER COLUMN)\s+\[?(\w+)\]?\s+')
                    foreach ($match in $columnMatches) {
                      $columnName = $match.Groups[1].Value
                      if ($columnName -notmatch $rules.naming_conventions.column_pattern) {
                        $warnings += "Column naming: $($rules.naming_conventions.column_message) (found: $columnName)"
                      }
                    }
                  }
                }
                
                # Performance checks
                if ($rules.performance_checks.enabled) {
                  if ($content -match '(?i)\bSELECT\s+\*\s+FROM') {
                    $warnings += "Performance: SELECT * detected (consider specifying columns)"
                  }
                }
                
                # Security checks
                if ($rules.security_checks.enabled) {
                  if ($content -match '(?i)\bEXEC\s*\(\s*@') {
                    $warnings += "Security: Dynamic SQL detected (review for SQL injection risks)"
                  }
                  if ($content -match '(?i)\b(UPDATE|DELETE)\b(?!\s+.*\bWHERE\b)') {
                    $errors += "Security: UPDATE/DELETE without WHERE clause detected"
                  }
                }
              } else {
                # Fallback to basic rules if rules.yml not loaded
                if ($content -match '(?i)\bDROP\s+TABLE\b') {
                  $errors += "DROP TABLE detected (dangerous operation)"
                }
                if ($content -match '(?i)\bTRUNCATE\s+TABLE\b') {
                  $errors += "TRUNCATE TABLE detected (data loss risk)"
                }
                if ($content -match '(?i)\bDROP\s+DATABASE\b') {
                  $errors += "DROP DATABASE detected (CRITICAL - not allowed)"
                }
              }
              
              # Check for GO terminator
              if ($content -notmatch '(?i)\bGO\b\s*$') {
                $errors += "Missing GO terminator at end of file"
              }
              
              # Display warnings
              if ($warnings.Count -gt 0) {
                $warnings | ForEach-Object { 
                  Write-Host "    ‚ö†Ô∏è  WARNING: $_" -ForegroundColor Yellow 
                  $totalWarnings++
                }
              }
              
              # Display errors
              if ($errors.Count -gt 0) {
                Write-Host "    ‚ùå Validation FAILED" -ForegroundColor Red
                $errors | ForEach-Object { 
                  Write-Host "       - $_" -ForegroundColor Red 
                  $totalErrors++
                }
                $validationFailed = $true
              } else {
                Write-Host "    ‚úÖ Validation PASSED" -ForegroundColor Green
              }
            }
          }
          
          Write-Host ""
          Write-Host "========================================="
          Write-Host "VALIDATION SUMMARY"
          Write-Host "========================================="
          Write-Host "Total errors: $totalErrors"
          Write-Host "Total warnings: $totalWarnings"
          
          if ($validationFailed) {
            Write-Host "Status: ‚ùå FAILED" -ForegroundColor Red
            Write-Host "========================================="
            throw "Validation failed"
          }
          
          Write-Host "Status: ‚úÖ PASSED" -ForegroundColor Green
          Write-Host "========================================="

      - name: Deploy to STAGING (per project)
        if: steps.detect_projects.outputs.has_changes == 'true'
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          $ErrorActionPreference='Stop'
          $PORT = if ($env:P) { $env:P } else { "1433" }
          
          Write-Host ""
          Write-Host "========================================="
          Write-Host "DEPLOYING TO STAGING"
          Write-Host "========================================="
          
          $projects = '${{ steps.detect_projects.outputs.projects }}'.Split(',') | Where-Object { $_ }
          $totalDeployed = 0
          $deploymentLog = @()
          
          foreach ($proj in $projects) {
            Write-Host ""
            Write-Host "üìÅ Deploying project: $proj" -ForegroundColor Cyan
            Write-Host "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            
            $fileList = "_changed_${proj}.txt"
            if (!(Test-Path $fileList)) {
              Write-Host "  ‚ö†Ô∏è No file list found, skipping"
              continue
            }
            
            $files = Get-Content $fileList | Sort-Object
            $projectDeployed = 0
            
            # Check if project has ALTER statements - if yes, create backup
            $hasAlter = $false
            foreach ($file in $files) {
              if ((Get-Content $file -Raw) -match '(?i)\bALTER\s+TABLE') {
                $hasAlter = $true
                break
              }
            }
            
            if ($hasAlter) {
              Write-Host "  üì¶ Project contains ALTER - creating backup..." -ForegroundColor Yellow
              # Auto-backup logic would go here
            }
            
            # Deploy files in order (sorted by filename)
            foreach ($file in $files) {
              $file = $file.Trim()
              if (!(Test-Path $file)) {
                Write-Host "  ‚ùå File not found: $file" -ForegroundColor Red
                throw "Deployment failed: file not found"
              }
              
              $fileName = Split-Path $file -Leaf
              Write-Host "  üöÄ Deploying: $fileName"
              
              $fullPath = Resolve-Path $file
              $sqlcmdArgs = @(
                "-S", "$env:H,$PORT",
                "-d", "$env:D",
                "-U", "$env:U",
                "-P", "$env:W",
                "-b", "-C",
                "-i", "`"$fullPath`""
              )
              
              $process = Start-Process -FilePath $env:SQLCMD_EXE -ArgumentList $sqlcmdArgs -Wait -PassThru -NoNewWindow
              
              if ($process.ExitCode -ne 0) {
                Write-Host "  ‚ùå FAILED: $fileName (exit code: $($process.ExitCode))" -ForegroundColor Red
                throw "Deployment failed for $file"
              }
              
              Write-Host "  ‚úÖ SUCCESS: $fileName" -ForegroundColor Green
              $projectDeployed++
              $totalDeployed++
              
              $deploymentLog += @{
                project = $proj
                file = $fileName
                status = "success"
                timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
              }
            }
            
            Write-Host "  üìä Project '$proj': deployed $projectDeployed file(s)" -ForegroundColor Cyan
          }
          
          Write-Host ""
          Write-Host "========================================="
          Write-Host "DEPLOYMENT SUMMARY"
          Write-Host "========================================="
          Write-Host "Total projects: $($projects.Count)"
          Write-Host "Total files deployed: $totalDeployed"
          Write-Host "Status: ‚úÖ SUCCESS"
          Write-Host "========================================="
          
          # Save deployment log
          $deploymentLog | ConvertTo-Json | Set-Content "deployment_log.json"

      - name: Upload deployment artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: staging-deployment-logs
          path: |
            _changed_*.txt
            _validation_rules.json
            deployment_log.json
          if-no-files-found: ignore

      - name: Comment on PR
        if: always() && steps.detect_projects.outputs.has_changes == 'true' && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const projects = '${{ steps.detect_projects.outputs.projects }}'.split(',').filter(x => x);
            
            let comment = '## üöÄ Staging Deployment Report\n\n';
            comment += `**Status:** ${{ job.status == 'success' && '‚úÖ SUCCESS' || '‚ùå FAILED' }}\n`;
            comment += `**Environment:** STAGING\n`;
            comment += `**Projects deployed:** ${projects.length}\n\n`;
            
            if (projects.length > 0) {
              comment += '### üìÅ Projects\n\n';
              for (const proj of projects) {
                comment += `#### ${proj}\n\n`;
                const fileList = `_changed_${proj}.txt`;
                if (fs.existsSync(fileList)) {
                  const files = fs.readFileSync(fileList, 'utf8').trim().split('\n');
                  comment += '| File | Status |\n';
                  comment += '|------|--------|\n';
                  files.forEach(file => {
                    const fileName = file.split('/').pop();
                    const status = '${{ job.status }}' === 'success' ? '‚úÖ' : '‚ùå';
                    comment += `| \`${fileName}\` | ${status} |\n`;
                  });
                  comment += '\n';
                }
              }
            } else {
              comment += 'No projects were deployed.\n\n';
            }
            
            comment += '\n---\n';
            comment += `_Deployed at ${new Date().toISOString()}_`;
            
            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } catch (error) {
              console.log('Could not create comment on PR:', error.message);
            }