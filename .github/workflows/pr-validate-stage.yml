name: Validate & Deploy to STAGING (Modular)

on:
  pull_request:
    paths:
      - "deploy/**/*.sql"
      - "tables/**/*.yml"
      - "tables/**/*.yaml"
      - "scripts/**"
      - "rules.yml"
      - ".github/workflows/**"

defaults:
  run:
    shell: cmd

jobs:
  setup:
    runs-on: [self-hosted, Windows]
    outputs:
      create_changed: ${{ steps.chg_create.outputs.has_changes }}
      create_count:   ${{ steps.chg_create.outputs.file_count }}
      alter_changed:  ${{ steps.chg_alter.outputs.has_changes }}
      alter_count:    ${{ steps.chg_alter.outputs.file_count }}
      drop_changed:   ${{ steps.chg_drop.outputs.has_changes }}
      drop_count:     ${{ steps.chg_drop.outputs.file_count }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve sqlcmd
        shell: powershell
        env:
          VAR_SQLCMD: ${{ vars.SQLCMD_EXE }}
        run: |
          $ErrorActionPreference='Stop'
          function Exists($p){ if([string]::IsNullOrWhiteSpace($p)){return $false}; Test-Path $p }
          $c=@()
          if($env:VAR_SQLCMD){ $c+=$env:VAR_SQLCMD }
          try{ $found=& where.exe sqlcmd 2>$null; if($LASTEXITCODE -eq 0){ $c+=($found -split "`r?`n" | ? { $_ -and (Test-Path $_) }) } }catch{}
          $c+=@(
            "C:\Program Files\SqlCmd\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          )
          $pick=$c|?{Exists $_}|Select-Object -First 1
          if(-not $pick){ throw "sqlcmd.exe not found. Set repo variable SQLCMD_EXE or install SQL tools." }
          "SQLCMD_EXE=$pick" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
          Write-Host "Using sqlcmd: $pick"

      - name: DNS & TCP checks (STAGING)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
        run: |
          nslookup %H% || (echo DNS FAILED & exit /b 1)
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          powershell -Command "if(!(Test-NetConnection -ComputerName '%H%' -Port ([int]'%PORT%') -InformationLevel Quiet)){exit 1}"

      - name: Test sqlcmd login (STAGING)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          echo Target: %H%,%PORT% / DB=%D%
          "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -l 10 -b -C -Q "SELECT 1"

      - name: Compute CREATE changes
        id: chg_create
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          git config --global --add safe.directory "$env:GITHUB_WORKSPACE" 2>$null
          try { git fetch origin --depth=100 2>$null; git fetch --all --tags --prune 2>$null } catch {}
          $base='${{ github.base_ref }}'
          if ($base) {
            try { git fetch origin "${base}:refs/remotes/origin/$base" --depth=100 2>$null } catch {}
            $range="origin/$base...HEAD"
          } else {
            $before='${{ github.event.before }}'
            if ([string]::IsNullOrWhiteSpace($before) -or $before -match '^0+$') { $range='HEAD~1...HEAD' } else { $range="$before...HEAD" }
          }
          $all = @()
          if (Test-Path 'deploy/create') {
            $diff = git -c core.quotepath=false diff --name-only --diff-filter=AMR $range -- "deploy/create/*.sql" 2>$null
            $wt   = git ls-files -mo --exclude-standard -- "deploy/create/*.sql" 2>$null
            if($diff){ $all+=$diff }; if($wt){ $all+=$wt }
            $all=$all | Where-Object { $_ -and (Test-Path $_) } | Sort-Object -Unique
          }
          Write-Host "Found $($all.Count) CREATE file(s)"
          $outDeploy = 'deploy/_changed_create.txt'
          $outRoot   = '_changed_create.txt'
          if ($all.Count -gt 0) {
            $all | Set-Content -Encoding UTF8 -LiteralPath $outDeploy
            $all | Set-Content -Encoding UTF8 -LiteralPath $outRoot
            "has_changes=true" | Out-File $env:GITHUB_OUTPUT -Append
            "file_count=$($all.Count)" | Out-File $env:GITHUB_OUTPUT -Append
          } else {
            "" | Set-Content -Encoding UTF8 -LiteralPath $outDeploy -NoNewline
            "" | Set-Content -Encoding UTF8 -LiteralPath $outRoot   -NoNewline
            "has_changes=false" | Out-File $env:GITHUB_OUTPUT -Append
            "file_count=0" | Out-File $env:GITHUB_OUTPUT -Append
          }

      - name: Compute ALTER changes
        id: chg_alter
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          $base='${{ github.base_ref }}'
          if ($base) { $range="origin/$base...HEAD" } else {
            $before='${{ github.event.before }}'
            if ([string]::IsNullOrWhiteSpace($before) -or $before -match '^0+$') { $range='HEAD~1...HEAD' } else { $range="$before...HEAD" }
          }
          $all=@()
          if (Test-Path 'deploy/alter') {
            $diff = git -c core.quotepath=false diff --name-only --diff-filter=AMR $range -- "deploy/alter/*.sql" 2>$null
            $wt   = git ls-files -mo --exclude-standard -- "deploy/alter/*.sql" 2>$null
            if($diff){ $all+=$diff }; if($wt){ $all+=$wt }
            $all=$all | Where-Object { $_ -and (Test-Path $_) } | Sort-Object -Unique
          }
          Write-Host "Found $($all.Count) ALTER file(s)"
          $outDeploy = 'deploy/_changed_alter.txt'
          $outRoot   = '_changed_alter.txt'
          if ($all.Count -gt 0) {
            $all | Set-Content -Encoding UTF8 -LiteralPath $outDeploy
            $all | Set-Content -Encoding UTF8 -LiteralPath $outRoot
            "has_changes=true" | Out-File $env:GITHUB_OUTPUT -Append
            "file_count=$($all.Count)" | Out-File $env:GITHUB_OUTPUT -Append
          } else {
            "" | Set-Content -Encoding UTF8 -LiteralPath $outDeploy -NoNewline
            "" | Set-Content -Encoding UTF8 -LiteralPath $outRoot   -NoNewline
            "has_changes=false" | Out-File $env:GITHUB_OUTPUT -Append
            "file_count=0" | Out-File $env:GITHUB_OUTPUT -Append
          }

      - name: Compute DROP changes
        id: chg_drop
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          $base='${{ github.base_ref }}'
          if ($base) { $range="origin/$base...HEAD" } else {
            $before='${{ github.event.before }}'
            if ([string]::IsNullOrWhiteSpace($before) -or $before -match '^0+$') { $range='HEAD~1...HEAD' } else { $range="$before...HEAD" }
          }
          $all=@()
          if (Test-Path 'deploy/drop') {
            $diff = git -c core.quotepath=false diff --name-only --diff-filter=AMR $range -- "deploy/drop/*.sql" 2>$null
            $wt   = git ls-files -mo --exclude-standard -- "deploy/drop/*.sql" 2>$null
            if($diff){ $all+=$diff }; if($wt){ $all+=$wt }
            $all=$all | Where-Object { $_ -and (Test-Path $_) } | Sort-Object -Unique
          }
          Write-Host "Found $($all.Count) DROP file(s)"
          $outDeploy = 'deploy/_changed_drop.txt'
          $outRoot   = '_changed_drop.txt'
          if ($all.Count -gt 0) {
            $all | Set-Content -Encoding UTF8 -LiteralPath $outDeploy
            $all | Set-Content -Encoding UTF8 -LiteralPath $outRoot
            "has_changes=true" | Out-File $env:GITHUB_OUTPUT -Append
            "file_count=$($all.Count)" | Out-File $env:GITHUB_OUTPUT -Append
          } else {
            "" | Set-Content -Encoding UTF8 -LiteralPath $outDeploy -NoNewline
            "" | Set-Content -Encoding UTF8 -LiteralPath $outRoot   -NoNewline
            "has_changes=false" | Out-File $env:GITHUB_OUTPUT -Append
            "file_count=0" | Out-File $env:GITHUB_OUTPUT -Append
          }

      - name: Upload change lists
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: changed-sql-lists
          path: |
            deploy/_changed_*.txt
            _changed_*.txt
          if-no-files-found: error
          retention-days: 7

      - name: Summary
        if: always()
        shell: powershell
        run: |
          Write-Host ""
          Write-Host "========================================="
          Write-Host "DEPLOYMENT SUMMARY"
          Write-Host "========================================="
          Write-Host "CREATE files: ${{ steps.chg_create.outputs.file_count }}"
          Write-Host "ALTER files:  ${{ steps.chg_alter.outputs.file_count }}"
          Write-Host "DROP files:   ${{ steps.chg_drop.outputs.file_count }}"
          Write-Host "========================================="

  deploy_create_stg:
    needs: setup
    if: needs.setup.outputs.create_changed == 'true' && needs.setup.outputs.create_count != '0'
    runs-on: [self-hosted, Windows]
    environment: staging
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/download-artifact@v4
        with:
          name: changed-sql-lists
          path: .
          merge-multiple: true

      - name: Resolve & check sqlcmd
        shell: cmd
        run: |
          setlocal EnableExtensions EnableDelayedExpansion
          set "SQLCMD_EXE=${{ vars.SQLCMD_EXE }}"
          if not defined SQLCMD_EXE if exist "C:\Program Files\SqlCmd\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\SqlCmd\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE (
            for /f "delims=" %%I in ('where sqlcmd 2^>NUL') do if not defined SQLCMD_EXE set "SQLCMD_EXE=%%I"
          )
          if not defined SQLCMD_EXE (
            echo [ERROR] sqlcmd.exe not found. Set repository variable SQLCMD_EXE or install SQL tools.
            exit /b 1
          )
          echo Using sqlcmd: %SQLCMD_EXE%
          "%SQLCMD_EXE%" -? >NUL || (echo [ERROR] sqlcmd not executable & exit /b 1)
          echo SQLCMD_EXE=%SQLCMD_EXE%>>%GITHUB_ENV%

      - name: Resolve change-list paths (CREATE/ALTER/DROP)
        shell: powershell
        run: |
          $pairs = @(
            @{ key="CREATE"; deploy="deploy/_changed_create.txt"; root="_changed_create.txt" },
            @{ key="ALTER";  deploy="deploy/_changed_alter.txt";  root="_changed_alter.txt"  },
            @{ key="DROP";   deploy="deploy/_changed_drop.txt";   root="_changed_drop.txt"   }
          )
          foreach($p in $pairs){
            $found = $null
            foreach($cand in @($p.deploy, $p.root)){
              if(Test-Path $cand){ $found = $cand; break }
            }
            if(-not $found){
              Write-Error "Missing change list ($($p.key)). Tried: $($p.deploy), $($p.root))"
              exit 1
            }
            Write-Host "Using $($p.key) list at: $found"
            "${($p.key)}_PATH=$found" | Out-File -FilePath $env:GITHUB_ENV -Append
          }

      - name: Verify change list exists (CREATE)
        shell: powershell
        run: |
          Write-Host "Checking for $env:CREATE_PATH ..."
          if (!(Test-Path $env:CREATE_PATH)) {
            Write-Host "::error::File not found: $env:CREATE_PATH"
            exit 1
          }
          $content = Get-Content $env:CREATE_PATH -Raw -ErrorAction SilentlyContinue
          Write-Host "File content length: $($content.Length) chars"
          if ([string]::IsNullOrWhiteSpace($content)) {
            Write-Host "::error::CREATE list is empty!"
            exit 1
          }
          $lines = $content -split "`n" | Where-Object { $_.Trim() }
          Write-Host "[OK] Found $($lines.Count) file(s) to deploy:"
          $lines | ForEach-Object { Write-Host "  - $($_.Trim())" }

      - name: Show changed list (CREATE)
        shell: powershell
        run: |
          Write-Host "Files to be deployed:"
          Get-Content $env:CREATE_PATH | ForEach-Object { 
            Write-Host "  > $_"
            if (Test-Path $_) {
              $size = (Get-Item $_).Length
              Write-Host "    Size: $size bytes"
            } else {
              Write-Host "    [WARNING] File not found in workspace!"
            }
          }

      - name: Deploy CREATE (changed only)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        shell: cmd
        run: |
          setlocal EnableDelayedExpansion
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          if not exist "%CREATE_PATH%" (
            echo [ERROR] No changed CREATE list found at %CREATE_PATH%.
            exit /b 1
          )
          set "DEPLOYED=0"
          set "FAILED=0"
          for /f "usebackq delims=" %%F in (`type "%CREATE_PATH%"`) do (
            if not "%%F"=="" (
              if exist "%%F" (
                echo.
                echo =====================================
                echo [DEPLOY] CREATE: %%~nxF
                echo =====================================
                "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -b -C -i "%%F"
                if errorlevel 1 (
                  echo [FAILED] %%~nxF
                  set /a FAILED+=1
                  exit /b 1
                ) else (
                  echo [SUCCESS] %%~nxF
                  set /a DEPLOYED+=1
                )
              ) else (
                echo [ERROR] File not found: %%F
                exit /b 1
              )
            )
          )
          echo.
          echo =====================================
          echo [SUMMARY] CREATE Deployment
          echo =====================================
          echo Deployed: !DEPLOYED!
          echo Failed: !FAILED!
          echo =====================================
          if !DEPLOYED! EQU 0 (
            echo [WARNING] No files were deployed!
            exit /b 1
          )

  deploy_alter_stg:
    needs: [setup, deploy_create_stg]
    if: needs.setup.outputs.alter_changed == 'true' && needs.setup.outputs.alter_count != '0'
    runs-on: [self-hosted, Windows]
    environment: staging
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/download-artifact@v4
        with:
          name: changed-sql-lists
          path: .
          merge-multiple: true

      - name: Resolve & check sqlcmd
        shell: cmd
        run: |
          setlocal EnableExtensions EnableDelayedExpansion
          set "SQLCMD_EXE=${{ vars.SQLCMD_EXE }}"
          if not defined SQLCMD_EXE if exist "C:\Program Files\SqlCmd\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\SqlCmd\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE (
            for /f "delims=" %%I in ('where sqlcmd 2^>NUL') do if not defined SQLCMD_EXE set "SQLCMD_EXE=%%I"
          )
          if not defined SQLCMD_EXE (
            echo [ERROR] sqlcmd.exe not found.
            exit /b 1
          )
          echo Using sqlcmd: %SQLCMD_EXE%
          "%SQLCMD_EXE%" -? >NUL || exit /b 1
          echo SQLCMD_EXE=%SQLCMD_EXE%>>%GITHUB_ENV%

      - name: Resolve change-list paths (CREATE/ALTER/DROP)
        shell: powershell
        run: |
          $pairs = @(
            @{ key="CREATE"; deploy="deploy/_changed_create.txt"; root="_changed_create.txt" },
            @{ key="ALTER";  deploy="deploy/_changed_alter.txt";  root="_changed_alter.txt"  },
            @{ key="DROP";   deploy="deploy/_changed_drop.txt";   root="_changed_drop.txt"   }
          )
          foreach($p in $pairs){
            $found = $null
            foreach($cand in @($p.deploy, $p.root)){
              if(Test-Path $cand){ $found = $cand; break }
            }
            if(-not $found){
              Write-Error "Missing change list ($($p.key)). Tried: $($p.deploy), $($p.root))"
              exit 1
            }
            Write-Host "Using $($p.key) list at: $found"
            "${($p.key)}_PATH=$found" | Out-File -FilePath $env:GITHUB_ENV -Append
          }

      - name: Show changed list (ALTER)
        shell: cmd
        run: |
          if not exist "%ALTER_PATH%" ( echo [ERROR] Missing file & exit /b 1 )
          echo Files to deploy:
          type "%ALTER_PATH%"

      - name: Deploy ALTER (changed only)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        shell: cmd
        run: |
          setlocal EnableDelayedExpansion
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          set "DEPLOYED=0"
          for /f "usebackq delims=" %%F in (`type "%ALTER_PATH%"`) do (
            if exist "%%F" (
              echo.
              echo [DEPLOY] ALTER: %%~nxF
              "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -b -C -i "%%F" || exit /b 1
              echo [SUCCESS] %%~nxF
              set /a DEPLOYED+=1
            ) else (
              echo [ERROR] File not found: %%F
              exit /b 1
            )
          )
          echo Deployed !DEPLOYED! ALTER file(s)

  deploy_drop_stg:
    needs: [setup, deploy_alter_stg]
    if: needs.setup.outputs.drop_changed == 'true' && needs.setup.outputs.drop_count != '0'
    runs-on: [self-hosted, Windows]
    environment: staging
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/download-artifact@v4
        with:
          name: changed-sql-lists
          path: .
          merge-multiple: true

      - name: Resolve & check sqlcmd
        shell: cmd
        run: |
          setlocal EnableExtensions EnableDelayedExpansion
          set "SQLCMD_EXE=${{ vars.SQLCMD_EXE }}"
          if not defined SQLCMD_EXE if exist "C:\Program Files\SqlCmd\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\SqlCmd\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE (
            for /f "delims=" %%I in ('where sqlcmd 2^>NUL') do if not defined SQLCMD_EXE set "SQLCMD_EXE=%%I"
          )
          if not defined SQLCMD_EXE (
            echo [ERROR] sqlcmd.exe not found.
            exit /b 1
          )
          echo Using sqlcmd: %SQLCMD_EXE%
          "%SQLCMD_EXE%" -? >NUL || exit /b 1
          echo SQLCMD_EXE=%SQLCMD_EXE%>>%GITHUB_ENV%

      - name: Resolve change-list paths (CREATE/ALTER/DROP)
        shell: powershell
        run: |
          $pairs = @(
            @{ key="CREATE"; deploy="deploy/_changed_create.txt"; root="_changed_create.txt" },
            @{ key="ALTER";  deploy="deploy/_changed_alter.txt";  root="_changed_alter.txt"  },
            @{ key="DROP";   deploy="deploy/_changed_drop.txt";   root="_changed_drop.txt"   }
          )
          foreach($p in $pairs){
            $found = $null
            foreach($cand in @($p.deploy, $p.root)){
              if(Test-Path $cand){ $found = $cand; break }
            }
            if(-not $found){
              Write-Error "Missing change list ($($p.key)). Tried: $($p.deploy), $($p.root))"
              exit 1
            }
            Write-Host "Using $($p.key) list at: $found"
            "${($p.key)}_PATH=$found" | Out-File -FilePath $env:GITHUB_ENV -Append
          }

      - name: Guard allowlist DROP
        shell: powershell
        run: |
          $allow=Get-Content -ErrorAction SilentlyContinue '.github\drop-allowlist.txt'
          if(-not $allow){Write-Host "::warning No drop-allowlist.txt -> all DROP blocked";exit 1}
          $rx=[regex]'(?is)\bdrop\s+table\s+(?:\[?(?<s>\w+)\]?\.)?\[?(?<t>\w+)\]?'
          foreach($f in Get-Content $env:DROP_PATH){
            $c=Get-Content $f -Raw
            foreach($m in $rx.Matches($c)){
              $s=$m.Groups['s'].Success?$m.Groups['s'].Value:'dbo'
              $t=$m.Groups['t'].Value
              $full="$s.$t"
              if($allow -notcontains $full){Write-Error "DROP not in allowlist: $full (file $f)"}
            }
          }

      - name: Show changed list (DROP)
        shell: cmd
        run: |
          if not exist "%DROP_PATH%" ( echo [ERROR] Missing file & exit /b 1 )
          type "%DROP_PATH%"

      - name: Deploy DROP (changed only)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        shell: cmd
        run: |
          setlocal EnableDelayedExpansion
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          set "DEPLOYED=0"
          for /f "usebackq delims=" %%F in (`type "%DROP_PATH%"`) do (
            if exist "%%F" (
              echo.
              echo [DEPLOY] DROP: %%~nxF
              "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -b -C -i "%%F" || exit /b 1
              echo [SUCCESS] %%~nxF
              set /a DEPLOYED+=1
            ) else (
              echo [ERROR] File not found: %%F
              exit /b 1
            )
          )
          echo Deployed !DEPLOYED! DROP file(s)