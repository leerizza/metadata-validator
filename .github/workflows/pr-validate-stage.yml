name: PR ‚Üí Validate & Deploy to STAGING

on:
  pull_request:
    paths:
      - "deploy/**/*.sql"
      - "rules.yml"
      - ".github/**"

permissions:
  contents: read
  pull-requests: write
  issues: write

defaults:
  run:
    shell: powershell

jobs:
  validate_and_deploy:
    runs-on: [self-hosted, Windows]
    environment: staging

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve sqlcmd
        run: |
          $ErrorActionPreference='Stop'
          $sqlcmdPaths = @(
            "${{ vars.SQLCMD_EXE }}",
            "C:\Program Files\SqlCmd\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          )
          $sqlcmd = $sqlcmdPaths | Where-Object { $_ -and (Test-Path $_) } | Select-Object -First 1
          if (!$sqlcmd) {
            try { $sqlcmd = (where.exe sqlcmd 2>$null) } catch {}
          }
          if (!$sqlcmd) { throw "sqlcmd.exe not found" }
          Write-Host "Using sqlcmd: $sqlcmd"
          Add-Content -Path $env:GITHUB_ENV -Value "SQLCMD_EXE=$sqlcmd"

      - name: Test database connection
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          $ErrorActionPreference='Stop'
          $PORT = if ($env:P) { $env:P } else { "1433" }
          Write-Host "Testing connection to $env:H,$PORT..."
          $ok = Test-NetConnection -ComputerName $env:H -Port $PORT -InformationLevel Quiet -WarningAction SilentlyContinue
          if (!$ok) { throw "Cannot reach database host" }
          & $env:SQLCMD_EXE -S "$env:H,$PORT" -d $env:D -U $env:U -P $env:W -l 10 -b -C -Q "SELECT 1"
          if ($LASTEXITCODE -ne 0) { throw "Database login failed" }
          Write-Host "‚úÖ Database connection successful"

      - name: Detect changed projects
        id: detect_projects
        run: |
          $ErrorActionPreference='Stop'
          git config --global --add safe.directory "$env:GITHUB_WORKSPACE" 2>$null
          try {
            git fetch origin --depth=100 2>$null
            git fetch --all --tags --prune 2>$null
          } catch {}

          $base = '${{ github.base_ref }}'
          if ($base) {
            try { git fetch origin "${base}:refs/remotes/origin/$base" --depth=100 2>$null } catch {}
            $range = "origin/$base...HEAD"
          } else {
            $before = '${{ github.event.before }}'
            if ([string]::IsNullOrWhiteSpace($before) -or $before -match '^0+$') { $range = 'HEAD~1...HEAD' } else { $range = "$before...HEAD" }
          }
          Write-Host "Git diff range: $range"

          $changedFiles   = git -c core.quotepath=false diff --name-only --diff-filter=AMR $range -- "deploy/**/*.sql" 2>$null
          $untrackedFiles = git ls-files -mo --exclude-standard -- "deploy/**/*.sql" 2>$null

          $allFiles = @()
          if ($changedFiles) { $allFiles += $changedFiles }
          if ($untrackedFiles) { $allFiles += $untrackedFiles }
          $allFiles = $allFiles | Where-Object { $_ -and (Test-Path $_) } | Sort-Object -Unique

          if ($allFiles.Count -eq 0) {
            Write-Host "‚ÑπÔ∏è No SQL files changed in deploy/"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "projects="
            Add-Content -Path $env:GITHUB_OUTPUT -Value "has_changes=false"
            exit 0
          }

          $projects = @{}
          foreach ($file in $allFiles) {
            if ($file -match '^deploy/([^/]+)/') {
              $proj = $Matches[1]
              if (!$projects.ContainsKey($proj)) { $projects[$proj] = @() }
              $projects[$proj] += $file
            }
          }

          Write-Host "`n========================================="
          Write-Host "CHANGED PROJECTS DETECTED"
          Write-Host "========================================="
          foreach ($p in $projects.Keys | Sort-Object) {
            Write-Host "üìÅ $p ($($projects[$p].Count) files)"
            $projects[$p] | Sort-Object | ForEach-Object { Write-Host "   - $_" }
          }
          Write-Host "========================================="

          $projectList = ($projects.Keys | Sort-Object) -join ','
          Add-Content -Path $env:GITHUB_OUTPUT -Value "projects=$projectList"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "has_changes=true"

          foreach ($p in $projects.Keys) {
            $projects[$p] | Set-Content "_changed_${p}.txt" -Encoding UTF8
          }

      - name: Load validation rules (safe)
        id: load_rules
        if: steps.detect_projects.outputs.has_changes == 'true'
        run: |
          $ErrorActionPreference='Stop'
          if (!(Test-Path "rules.yml")) {
            Write-Host "‚ö†Ô∏è rules.yml not found, using basic validation"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "rules_loaded=false"
            exit 0
          }

          $rulesObj = $null
          try {
            if (Get-Command ConvertFrom-Yaml -ErrorAction SilentlyContinue) {
              $rulesObj = Get-Content "rules.yml" -Raw | ConvertFrom-Yaml
            } else {
              Import-Module powershell-yaml -ErrorAction Stop
              $rulesObj = Get-Content "rules.yml" -Raw | ConvertFrom-Yaml
            }
          } catch {
            Write-Host "‚ö†Ô∏è YAML parse failed, fallback to basic validation: $($_.Exception.Message)"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "rules_loaded=false"
            exit 0
          }

          # Normalize -> JSON we‚Äôll consume later
          function As-Array($v) { if ($null -eq $v) { @() } elseif ($v -is [System.Collections.IEnumerable] -and -not ($v -is [string])) { @($v) } else { @($v) } }

          $normalized = [pscustomobject]@{
            type_guards = @{
              create = @{
                enabled  = [bool]$rulesObj.type_guards.create.enabled
                rules    = As-Array $rulesObj.type_guards.create.disallowed_patterns
              }
              alter = @{
                enabled  = [bool]$rulesObj.type_guards.alter.enabled
                rules    = As-Array $rulesObj.type_guards.alter.disallowed_patterns
              }
              drop = @{
                enabled  = [bool]$rulesObj.type_guards.drop.enabled
                rules    = @()
              }
            }
            naming_conventions = @{
              enabled        = [bool]$rulesObj.naming_conventions.enabled
              tables         = @{
                pattern = "$($rulesObj.naming_conventions.tables.pattern)"
                message = "$($rulesObj.naming_conventions.tables.message)"
              }
              columns        = @{
                pattern = "$($rulesObj.naming_conventions.columns.pattern)"
                message = "$($rulesObj.naming_conventions.columns.message)"
              }
            }
            performance_checks = @{
              enabled = [bool]$rulesObj.performance_checks.enabled
              rules   = As-Array $rulesObj.performance_checks.rules
            }
            security_checks = @{
              enabled = [bool]$rulesObj.security_checks.enabled
              rules   = As-Array $rulesObj.security_checks.rules
            }
            data_integrity = @{
              enabled = [bool]$rulesObj.data_integrity.enabled
              rules   = As-Array $rulesObj.data_integrity.rules
            }
            code_quality = @{
              enabled = [bool]$rulesObj.code_quality.enabled
              rules   = As-Array $rulesObj.code_quality.rules
            }
            custom_rules = @{
              enabled = [bool]$rulesObj.custom_rules.enabled
              rules   = As-Array $rulesObj.custom_rules.rules
            }
            deployment_safety = @{
              enabled = [bool]$rulesObj.deployment_safety.enabled
              rules   = As-Array $rulesObj.deployment_safety.rules
            }
          }

          $normalized | ConvertTo-Json -Depth 20 | Set-Content "_validation_rules.json" -Encoding UTF8
          Write-Host "‚úÖ Loaded rules from rules.yml"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "rules_loaded=true"


      - name: Validate SQL files
        if: steps.detect_projects.outputs.has_changes == 'true'
        run: |
          $ErrorActionPreference='Stop'
          Write-Host "`n========================================="
          Write-Host "VALIDATING SQL FILES"
          Write-Host "========================================="

          if (!(Test-Path "_validation_rules.json")) {
            Write-Host "‚ö†Ô∏è Rules not loaded; basic validation only"
            $rules = $null
          } else {
            $rules = Get-Content "_validation_rules.json" | ConvertFrom-Json
          }

          # Helpers
          Add-Type -AssemblyName "System.Core" | Out-Null
          $ROpts = [System.Text.RegularExpressions.RegexOptions]::IgnoreCase -bor `
                   [System.Text.RegularExpressions.RegexOptions]::Singleline -bor `
                   [System.Text.RegularExpressions.RegexOptions]::Multiline
          function Test-Pat([string]$s,[string]$p){ if([string]::IsNullOrEmpty($p)){ $false } else { [regex]::IsMatch($s,$p,$ROpts) } }
          function Last-Line([string]$s){ ($s -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" } | Select-Object -Last 1) }

          $projects = '${{ steps.detect_projects.outputs.projects }}'.Split(',') | Where-Object { $_ }
          $validationFailed = $false
          $totalErrors = 0
          $totalWarnings = 0

          foreach ($proj in $projects) {
            $fileList = "_changed_${proj}.txt"
            if (!(Test-Path $fileList)) { continue }
            Write-Host "`nüìÅ Validating project: $proj"
            $files = Get-Content $fileList
            foreach ($file in $files) {
              $file = $file.Trim()
              if (!(Test-Path $file)) { continue }
              $content = Get-Content $file -Raw
              Write-Host "  Checking: $file"

              $errors = @()
              $warnings = @()

              $isCreate = Test-Pat $content '\bCREATE\s+(TABLE|PROCEDURE|FUNCTION|VIEW)\b'
              $isAlter  = Test-Pat $content '\bALTER\s+(TABLE|PROCEDURE|FUNCTION|VIEW)\b'

              if ($rules) {
                # --- Type Guards ---
                if ($rules.type_guards.create.enabled -and $isCreate) {
                  foreach ($r in $rules.type_guards.create.rules) {
                    if (Test-Pat $content $r.pattern) {
                      if ($r.severity -eq 'error') { $errors += "$($r.name): $($r.message)" } else { $warnings += "$($r.name): $($r.message)" }
                    }
                  }
                }
                if ($rules.type_guards.alter.enabled -and $isAlter) {
                  foreach ($r in $rules.type_guards.alter.rules) {
                    if (Test-Pat $content $r.pattern) {
                      if ($r.severity -eq 'error') { $errors += "$($r.name): $($r.message)" } else { $warnings += "$($r.name): $($r.message)" }
                    }
                  }
                }

                # --- Naming Conventions ---
                if ($rules.naming_conventions.enabled) {
                  if ($isCreate -and $rules.naming_conventions.tables.pattern) {
                    if ($content -match '(?i)CREATE\s+TABLE\s+(?:\[?([a-zA-Z0-9_]+)\]?\.)?\[?([a-zA-Z0-9_]+)\]?') {
                      $tableName = $Matches[2]
                      if (-not (Test-Pat $tableName $rules.naming_conventions.tables.pattern)) {
                        $warnings += "Table naming: $($rules.naming_conventions.tables.message) (found: $tableName)"
                      }
                    }
                  }
                  if ($rules.naming_conventions.columns.pattern) {
                    $colMatches = [regex]::Matches($content,'(?i)(?:ADD|ALTER\s+COLUMN)\s+\[?([a-zA-Z0-9_]+)\]?\s+',$ROpts)
                    foreach ($m in $colMatches) {
                      $c = $m.Groups[1].Value
                      if (-not (Test-Pat $c $rules.naming_conventions.columns.pattern)) {
                        $warnings += "Column naming: $($rules.naming_conventions.columns.message) (found: $c)"
                      }
                    }
                  }
                }

                # --- Category runners ---
                function Apply-Rules($label,$enabled,$list){
                  param([string]$label,[bool]$enabled,$list)
                  if(-not $enabled){ return @() }
                  $errs=@(); $warns=@()
                  foreach($r in $list){
                    $pat = "$($r.pattern)"
                    if([string]::IsNullOrEmpty($pat)){ continue }
                    if(Test-Pat $content $pat){
                      if($r.severity -eq 'error'){ $errs += "$($r.name): $($r.message)" } else { $warns += "$($r.name): $($r.message)" }
                    }
                  }
                  return @($errs,$warns)
                }

                $res = Apply-Rules "performance" ([bool]$rules.performance_checks.enabled) $rules.performance_checks.rules
                $errors += $res[0]; $warnings += $res[1]
                $res = Apply-Rules "security" ([bool]$rules.security_checks.enabled) $rules.security_checks.rules
                $errors += $res[0]; $warnings += $res[1]
                $res = Apply-Rules "data_integrity" ([bool]$rules.data_integrity.enabled) $rules.data_integrity.rules
                $errors += $res[0]; $warnings += $res[1]
                $res = Apply-Rules "code_quality" ([bool]$rules.code_quality.enabled) $rules.code_quality.rules
                $errors += $res[0]; $warnings += $res[1]
                $res = Apply-Rules "custom_rules" ([bool]$rules.custom_rules.enabled) $rules.custom_rules.rules
                $errors += $res[0]; $warnings += $res[1]

                # --- Deployment safety (specials) ---
                if ($rules.deployment_safety.enabled) {
                  foreach ($r in $rules.deployment_safety.rules) {
                    if ($r.name -eq 'Missing GO terminator') {
                      $last = Last-Line $content
                      if (($last -ne $null) -and ($last.ToUpper() -ne 'GO')) {
                        if ($r.severity -eq 'error') { $errors += $r.message } else { $warnings += $r.message }
                      }
                      continue
                    }
                    # default: regex apply
                    if (Test-Pat $content "$($r.pattern)") {
                      if ($r.severity -eq 'error') { $errors += "$($r.name): $($r.message)" } else { $warnings += "$($r.name): $($r.message)" }
                    }
                  }
                }
              } else {
                # Fallback minimal checks
                if (Test-Pat $content '\bDROP\s+DATABASE\b') { $errors += "DROP DATABASE detected (CRITICAL - not allowed)" }
                if (Test-Pat $content '\bTRUNCATE\s+TABLE\b') { $errors += "TRUNCATE TABLE detected (data loss risk)" }
                if (Test-Pat $content '\bDROP\s+TABLE\b')     { $warnings += "DROP TABLE detected" }
                # End must be GO (keep strict on fallback)
                $last = Last-Line $content
                if (($last -ne $null) -and ($last.ToUpper() -ne 'GO')) { $errors += "SQL file must end with GO statement" }
              }

              # Emit
              foreach ($w in $warnings) { Write-Host "    ‚ö†Ô∏è  $w" -ForegroundColor Yellow; $totalWarnings++ }
              if ($errors.Count -gt 0) {
                Write-Host "    ‚ùå Validation FAILED" -ForegroundColor Red
                foreach ($e in $errors) { Write-Host "       - $e" -ForegroundColor Red; $totalErrors++ }
                $validationFailed = $true
              } else {
                Write-Host "    ‚úÖ Validation PASSED" -ForegroundColor Green
              }
            }
          }

          Write-Host "`n========================================="
          Write-Host "VALIDATION SUMMARY"
          Write-Host "========================================="
          Write-Host "Total errors: $totalErrors"
          Write-Host "Total warnings: $totalWarnings"
          if ($validationFailed) { Write-Host "Status: ‚ùå FAILED" -ForegroundColor Red; Write-Host "========================================="; throw "Validation failed" }
          Write-Host "Status: ‚úÖ PASSED" -ForegroundColor Green
          Write-Host "========================================="


      - name: Deploy to STAGING (per project)
        if: steps.detect_projects.outputs.has_changes == 'true'
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          $ErrorActionPreference='Stop'
          $PORT = if ($env:P) { $env:P } else { "1433" }

          Write-Host "`n========================================="
          Write-Host "DEPLOYING TO STAGING"
          Write-Host "========================================="

          $projects = '${{ steps.detect_projects.outputs.projects }}'.Split(',') | Where-Object { $_ }
          $totalDeployed = 0
          $deploymentLog = @()

          foreach ($proj in $projects) {
            Write-Host "`nüìÅ Deploying project: $proj" -ForegroundColor Cyan
            Write-Host "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            $fileList = "_changed_${proj}.txt"
            if (!(Test-Path $fileList)) { Write-Host "  ‚ö†Ô∏è No file list found, skipping"; continue }

            $files = Get-Content $fileList | Sort-Object

            $hasAlter = $false
            foreach ($f in $files) { if ((Get-Content $f -Raw) -match '(?i)\bALTER\s+TABLE\b') { $hasAlter = $true; break } }
            if ($hasAlter) { Write-Host "  üì¶ Project contains ALTER - create backup here if needed" -ForegroundColor Yellow }

            foreach ($file in $files) {
              $file = $file.Trim()
              if (!(Test-Path $file)) { Write-Host "  ‚ùå File not found: $file" -ForegroundColor Red; throw "Deployment failed: file not found" }
              $fileName = Split-Path $file -Leaf
              Write-Host "  üöÄ Deploying: $fileName"
              $fullPath = Resolve-Path $file
              $args = @("-S","$env:H,$PORT","-d","$env:D","-U","$env:U","-P","$env:W","-b","-C","-i","`"$fullPath`"")
              $p = Start-Process -FilePath $env:SQLCMD_EXE -ArgumentList $args -Wait -PassThru -NoNewWindow
              if ($p.ExitCode -ne 0) { Write-Host "  ‚ùå FAILED: $fileName (exit $($p.ExitCode))" -ForegroundColor Red; throw "Deployment failed for $file" }
              Write-Host "  ‚úÖ SUCCESS: $fileName" -ForegroundColor Green
              $totalDeployed++
              $deploymentLog += @{ project=$proj; file=$fileName; status='success'; timestamp=(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') }
            }

            Write-Host "  üìä Project '$proj': deployed $(($deploymentLog | Where-Object { $_.project -eq $proj }).Count) file(s)" -ForegroundColor Cyan
          }

          Write-Host "`n========================================="
          Write-Host "DEPLOYMENT SUMMARY"
          Write-Host "========================================="
          Write-Host "Total projects: $($projects.Count)"
          Write-Host "Total files deployed: $totalDeployed"
          Write-Host "Status: ‚úÖ SUCCESS"
          Write-Host "========================================="

          $deploymentLog | ConvertTo-Json | Set-Content "deployment_log.json" -Encoding UTF8

      - name: Upload deployment artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: staging-deployment-logs
          path: |
            _changed_*.txt
            _validation_rules.json
            deployment_log.json
          if-no-files-found: ignore

      - name: Comment on PR
        if: always() && steps.detect_projects.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const projects = '${{ steps.detect_projects.outputs.projects }}'.split(',').filter(Boolean);

            let status = '${{ job.status }}' === 'success' ? '‚úÖ SUCCESS' : '‚ùå FAILED';
            let comment = '## üöÄ Staging Deployment Report\n\n';
            comment += `**Status:** ${status}\n`;
            comment += `**Environment:** STAGING\n`;
            comment += `**Projects deployed:** ${projects.length}\n\n`;
            comment += '### üìÅ Projects\n\n';

            for (const proj of projects) {
              comment += `#### ${proj}\n\n`;
              const fileList = `_changed_${proj}.txt`;
              if (fs.existsSync(fileList)) {
                const files = fs.readFileSync(fileList, 'utf8').trim().split('\n').filter(Boolean);
                comment += '| File | Status |\n|------|--------|\n';
                for (const f of files) {
                  const fileName = f.split('/').pop();
                  const icon = '${{ job.status }}' === 'success' ? '‚úÖ' : '‚ùå';
                  comment += `| \`${fileName}\` | ${icon} |\n`;
                }
                comment += '\n';
              }
            }
            comment += '\n---\n';
            comment += `_Deployed at ${new Date().toISOString()}_`;

            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } catch (e) {
              core.warning(`Skipping PR comment: ${e.message}`);
            }
