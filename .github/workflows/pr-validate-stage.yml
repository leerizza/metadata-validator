name: Validate & Deploy to STAGING (Project-Based)

on:
  pull_request:
    paths:
      - "deploy/**/*.sql"
      - "tables/**/*.yml"
      - "tables/**/*.yaml"
      - "scripts/**"
      - "rules.yml"
      - ".github/workflows/**"

defaults:
  run:
    shell: cmd

jobs:
  setup:
    runs-on: [self-hosted, Windows]
    outputs:
      create_changed: ${{ steps.classify.outputs.has_create }}
      create_count:   ${{ steps.classify.outputs.create_count }}
      alter_changed:  ${{ steps.classify.outputs.has_alter }}
      alter_count:    ${{ steps.classify.outputs.alter_count }}
      drop_changed:   ${{ steps.classify.outputs.has_drop }}
      drop_count:     ${{ steps.classify.outputs.drop_count }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve sqlcmd
        shell: powershell
        env:
          VAR_SQLCMD: ${{ vars.SQLCMD_EXE }}
        run: |
          $ErrorActionPreference='Stop'
          function Exists($p){ if([string]::IsNullOrWhiteSpace($p)){return $false}; Test-Path $p }
          $c=@()
          if($env:VAR_SQLCMD){ $c+=$env:VAR_SQLCMD }
          try{ $found=& where.exe sqlcmd 2>$null; if($LASTEXITCODE -eq 0){ $c+=($found -split "`r?`n" | ? { $_ -and (Test-Path $_) }) } }catch{}
          $c+=@(
            "C:\Program Files\SqlCmd\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          )
          $pick=$c|?{Exists $_}|Select-Object -First 1
          if(-not $pick){ throw "sqlcmd.exe not found. Set repo variable SQLCMD_EXE or install SQL tools." }
          "SQLCMD_EXE=$pick" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
          Write-Host "Using sqlcmd: $pick"

      - name: DNS & TCP checks (STAGING)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
        run: |
          nslookup %H% || (echo DNS FAILED & exit /b 1)
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          powershell -Command "if(!(Test-NetConnection -ComputerName '%H%' -Port ([int]'%PORT%') -InformationLevel Quiet)){exit 1}"

      - name: Test sqlcmd login (STAGING)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          echo Target: %H%,%PORT% / DB=%D%
          "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -l 10 -b -C -Q "SELECT 1"

      - name: Detect and Classify Changed SQL Files
        id: classify
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          git config --global --add safe.directory "$env:GITHUB_WORKSPACE" 2>$null
          
          try { 
            git fetch origin --depth=100 2>$null
            git fetch --all --tags --prune 2>$null 
          } catch {}
          
          $base='${{ github.base_ref }}'
          if ($base) {
            Write-Host "PR mode: base=$base"
            try { 
              git fetch origin "${base}:refs/remotes/origin/$base" --depth=100 2>$null 
            } catch {}
            $range="origin/$base...HEAD"
          } else {
            $before='${{ github.event.before }}'
            if ([string]::IsNullOrWhiteSpace($before) -or $before -match '^0+$') { 
              Write-Host "Using HEAD~1 (no valid before commit)"
              $range='HEAD~1...HEAD' 
            } else { 
              Write-Host "Using before commit: $before"
              $range="$before...HEAD" 
            }
          }
          
          Write-Host "Git diff range: $range"
          Write-Host "Current branch: $(git branch --show-current)"
          Write-Host "Current HEAD: $(git rev-parse HEAD)"
          
          # Get all changed SQL files in deploy folder
          $allFiles = @()
          if (Test-Path 'deploy') {
            $diff = git -c core.quotepath=false diff --name-only --diff-filter=AMR $range -- "deploy/**/*.sql" 2>$null
            $wt   = git ls-files -mo --exclude-standard -- "deploy/**/*.sql" 2>$null
            if($diff){ $allFiles+=$diff }
            if($wt){ $allFiles+=$wt }
            $allFiles=$allFiles | Where-Object { $_ -and (Test-Path $_) } | Sort-Object -Unique
          } else {
            Write-Host "[WARN] Folder deploy does not exist"
          }
          
          Write-Host ""
          Write-Host "Found $($allFiles.Count) changed SQL file(s) in deploy/"
          
          # Classify files by SQL operation type
          $createFiles = @()
          $alterFiles = @()
          $dropFiles = @()
          
          foreach ($file in $allFiles) {
            Write-Host "Analyzing: $file"
            $content = Get-Content $file -Raw
            
            # Detect operation type (case-insensitive, multiline)
            $hasCreate = $content -match '(?im)^\s*CREATE\s+(TABLE|PROCEDURE|FUNCTION|VIEW|INDEX)'
            $hasAlter  = $content -match '(?im)^\s*ALTER\s+(TABLE|PROCEDURE|FUNCTION|VIEW)'
            $hasDrop   = $content -match '(?im)^\s*DROP\s+(TABLE|PROCEDURE|FUNCTION|VIEW|INDEX)'
            
            if ($hasDrop) {
              $dropFiles += $file
              Write-Host "  -> DROP detected"
            }
            elseif ($hasAlter) {
              $alterFiles += $file
              Write-Host "  -> ALTER detected"
            }
            elseif ($hasCreate) {
              $createFiles += $file
              Write-Host "  -> CREATE detected"
            }
            else {
              Write-Host "  -> [WARNING] No operation detected, skipping"
            }
          }
          
          # Save classified files
          Write-Host ""
          Write-Host "Classification results:"
          Write-Host "  CREATE: $($createFiles.Count) files"
          Write-Host "  ALTER:  $($alterFiles.Count) files"
          Write-Host "  DROP:   $($dropFiles.Count) files"
          
          # Create list files
          if ($createFiles.Count -gt 0) {
            $createFiles | Set-Content -Encoding UTF8 -LiteralPath '_changed_create.txt'
            "has_create=true" | Out-File $env:GITHUB_OUTPUT -Append
            "create_count=$($createFiles.Count)" | Out-File $env:GITHUB_OUTPUT -Append
            Write-Host "[OK] CREATE files:"
            $createFiles | ForEach-Object { Write-Host "   - $_" }
          } else {
            "" | Set-Content -Encoding UTF8 -LiteralPath '_changed_create.txt' -NoNewline
            "has_create=false" | Out-File $env:GITHUB_OUTPUT -Append
            "create_count=0" | Out-File $env:GITHUB_OUTPUT -Append
            Write-Host "[INFO] No CREATE files"
          }
          
          if ($alterFiles.Count -gt 0) {
            $alterFiles | Set-Content -Encoding UTF8 -LiteralPath '_changed_alter.txt'
            "has_alter=true" | Out-File $env:GITHUB_OUTPUT -Append
            "alter_count=$($alterFiles.Count)" | Out-File $env:GITHUB_OUTPUT -Append
            Write-Host "[OK] ALTER files:"
            $alterFiles | ForEach-Object { Write-Host "   - $_" }
          } else {
            "" | Set-Content -Encoding UTF8 -LiteralPath '_changed_alter.txt' -NoNewline
            "has_alter=false" | Out-File $env:GITHUB_OUTPUT -Append
            "alter_count=0" | Out-File $env:GITHUB_OUTPUT -Append
            Write-Host "[INFO] No ALTER files"
          }
          
          if ($dropFiles.Count -gt 0) {
            $dropFiles | Set-Content -Encoding UTF8 -LiteralPath '_changed_drop.txt'
            "has_drop=true" | Out-File $env:GITHUB_OUTPUT -Append
            "drop_count=$($dropFiles.Count)" | Out-File $env:GITHUB_OUTPUT -Append
            Write-Host "[OK] DROP files:"
            $dropFiles | ForEach-Object { Write-Host "   - $_" }
          } else {
            "" | Set-Content -Encoding UTF8 -LiteralPath '_changed_drop.txt' -NoNewline
            "has_drop=false" | Out-File $env:GITHUB_OUTPUT -Append
            "drop_count=0" | Out-File $env:GITHUB_OUTPUT -Append
            Write-Host "[INFO] No DROP files"
          }

      - name: Upload change lists
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: changed-sql-lists
          path: |
            _changed_*.txt
          if-no-files-found: ignore

      - name: Summary
        if: always()
        shell: powershell
        run: |
          Write-Host ""
          Write-Host "========================================="
          Write-Host "DEPLOYMENT SUMMARY"
          Write-Host "========================================="
          Write-Host "CREATE files: ${{ steps.classify.outputs.create_count }}"
          Write-Host "ALTER files:  ${{ steps.classify.outputs.alter_count }}"
          Write-Host "DROP files:   ${{ steps.classify.outputs.drop_count }}"
          Write-Host "========================================="

  deploy_create_stg:
    needs: setup
    if: needs.setup.outputs.create_changed == 'true' && needs.setup.outputs.create_count != '0'
    runs-on: [self-hosted, Windows]
    environment: staging
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/download-artifact@v4
        with:
          name: changed-sql-lists
          path: ./

      - name: Resolve & check sqlcmd
        shell: cmd
        run: |
          setlocal EnableExtensions EnableDelayedExpansion
          set "SQLCMD_EXE=${{ vars.SQLCMD_EXE }}"
          if not defined SQLCMD_EXE if exist "C:\Program Files\SqlCmd\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\SqlCmd\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE (
            for /f "delims=" %%I in ('where sqlcmd 2^>NUL') do if not defined SQLCMD_EXE set "SQLCMD_EXE=%%I"
          )
          if not defined SQLCMD_EXE (
            echo [ERROR] sqlcmd.exe not found.
            exit /b 1
          )
          echo Using sqlcmd: %SQLCMD_EXE%
          "%SQLCMD_EXE%" -? >NUL || exit /b 1
          echo SQLCMD_EXE=%SQLCMD_EXE%>>%GITHUB_ENV%

      - name: Deploy CREATE files
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          
          $PORT = $env:P
          if ([string]::IsNullOrWhiteSpace($PORT)) { $PORT = "1433" }
          
          if (!(Test-Path '_changed_create.txt')) {
            Write-Error "File _changed_create.txt not found"
            exit 1
          }
          
          $files = Get-Content '_changed_create.txt' | Where-Object { $_.Trim() }
          if ($files.Count -eq 0) {
            Write-Error "No files in _changed_create.txt"
            exit 1
          }
          
          $DEPLOYED = 0
          $FAILED = 0
          
          foreach ($file in $files) {
            $trimmedFile = $file.Trim()
            if ([string]::IsNullOrWhiteSpace($trimmedFile)) { continue }
            
            Write-Host ""
            Write-Host "====================================="
            Write-Host "[DEPLOY CREATE] $trimmedFile"
            Write-Host "====================================="
            
            if (Test-Path $trimmedFile) {
              $fullPath = Resolve-Path $trimmedFile
              
              $sqlcmdArgs = @(
                "-S", "$env:H,$PORT",
                "-d", "$env:D", 
                "-U", "$env:U",
                "-P", "$env:W",
                "-b", "-C",
                "-i", "`"$fullPath`""
              )
              
              $process = Start-Process -FilePath $env:SQLCMD_EXE -ArgumentList $sqlcmdArgs -Wait -PassThru -NoNewWindow
              
              if ($process.ExitCode -eq 0) {
                Write-Host "[SUCCESS] $trimmedFile"
                $DEPLOYED++
              } else {
                Write-Host "[FAILED] $trimmedFile - Exit code: $($process.ExitCode)"
                $FAILED++
                exit 1
              }
            } else {
              Write-Host "[ERROR] File not found: $trimmedFile"
              $FAILED++
              exit 1
            }
          }
          
          Write-Host ""
          Write-Host "====================================="
          Write-Host "[SUMMARY] CREATE Deployment"
          Write-Host "====================================="
          Write-Host "Deployed: $DEPLOYED"
          Write-Host "Failed: $FAILED"
          Write-Host "====================================="
          
          if ($DEPLOYED -eq 0) {
            Write-Error "No files were deployed!"
            exit 1
          }

  deploy_alter_stg:
    needs: [setup, deploy_create_stg]
    if: needs.setup.outputs.alter_changed == 'true' && needs.setup.outputs.alter_count != '0'
    runs-on: [self-hosted, Windows]
    environment: staging
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/download-artifact@v4
        with:
          name: changed-sql-lists
          path: ./

      - name: Resolve & check sqlcmd
        shell: cmd
        run: |
          setlocal EnableExtensions EnableDelayedExpansion
          set "SQLCMD_EXE=${{ vars.SQLCMD_EXE }}"
          if not defined SQLCMD_EXE if exist "C:\Program Files\SqlCmd\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\SqlCmd\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE (
            for /f "delims=" %%I in ('where sqlcmd 2^>NUL') do if not defined SQLCMD_EXE set "SQLCMD_EXE=%%I"
          )
          if not defined SQLCMD_EXE (
            echo [ERROR] sqlcmd.exe not found.
            exit /b 1
          )
          echo Using sqlcmd: %SQLCMD_EXE%
          "%SQLCMD_EXE%" -? >NUL || exit /b 1
          echo SQLCMD_EXE=%SQLCMD_EXE%>>%GITHUB_ENV%

      - name: Deploy ALTER files
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $PORT = $env:P
          if ([string]::IsNullOrWhiteSpace($PORT)) { $PORT = "1433" }
          $DEPLOYED = 0
          
          $files = Get-Content '_changed_alter.txt' | Where-Object { $_.Trim() }
          foreach ($file in $files) {
            $trimmedFile = $file.Trim()
            if (Test-Path $trimmedFile) {
              Write-Host ""
              Write-Host "[DEPLOY ALTER] $trimmedFile"
              $fullPath = Resolve-Path $trimmedFile
              
              $sqlcmdArgs = @(
                "-S", "$env:H,$PORT",
                "-d", "$env:D", 
                "-U", "$env:U",
                "-P", "$env:W",
                "-b", "-C",
                "-i", "`"$fullPath`""
              )
              
              $process = Start-Process -FilePath $env:SQLCMD_EXE -ArgumentList $sqlcmdArgs -Wait -PassThru -NoNewWindow
              
              if ($process.ExitCode -eq 0) {
                Write-Host "[SUCCESS] $trimmedFile"
                $DEPLOYED++
              } else {
                Write-Error "Failed to deploy: $trimmedFile"
                exit 1
              }
            } else {
              Write-Error "File not found: $trimmedFile"
              exit 1
            }
          }
          Write-Host "Deployed $DEPLOYED ALTER file(s)"

  deploy_drop_stg:
    needs: [setup, deploy_alter_stg]
    if: needs.setup.outputs.drop_changed == 'true' && needs.setup.outputs.drop_count != '0'
    runs-on: [self-hosted, Windows]
    environment: staging
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/download-artifact@v4
        with:
          name: changed-sql-lists
          path: ./

      - name: Resolve & check sqlcmd
        shell: cmd
        run: |
          setlocal EnableExtensions EnableDelayedExpansion
          set "SQLCMD_EXE=${{ vars.SQLCMD_EXE }}"
          if not defined SQLCMD_EXE if exist "C:\Program Files\SqlCmd\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\SqlCmd\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE if exist "C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe" set "SQLCMD_EXE=C:\Program Files\Microsoft SQL Server\140\Tools\Binn\sqlcmd.exe"
          if not defined SQLCMD_EXE (
            for /f "delims=" %%I in ('where sqlcmd 2^>NUL') do if not defined SQLCMD_EXE set "SQLCMD_EXE=%%I"
          )
          if not defined SQLCMD_EXE (
            echo [ERROR] sqlcmd.exe not found.
            exit /b 1
          )
          echo Using sqlcmd: %SQLCMD_EXE%
          "%SQLCMD_EXE%" -? >NUL || exit /b 1
          echo SQLCMD_EXE=%SQLCMD_EXE%>>%GITHUB_ENV%

      - name: Guard allowlist DROP
        shell: powershell
        run: |
          $allow=Get-Content -ErrorAction SilentlyContinue '.github\drop-allowlist.txt'
          if(-not $allow){Write-Host "::warning No drop-allowlist.txt -> all DROP blocked";exit 1}
          $rx=[regex]'(?is)\bdrop\s+table\s+(?:\[?(?<s>\w+)\]?\.)?\[?(?<t>\w+)\]?'
          foreach($f in Get-Content '_changed_drop.txt'){
            if(Test-Path $f){
              $c=Get-Content $f -Raw
              foreach($m in $rx.Matches($c)){
                $s=$m.Groups['s'].Success?$m.Groups['s'].Value:'dbo'
                $t=$m.Groups['t'].Value
                $full="$s.$t"
                if($allow -notcontains $full){Write-Error "DROP not in allowlist: $full (file $f)"}
              }
            }
          }

      - name: Deploy DROP files
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $PORT = $env:P
          if ([string]::IsNullOrWhiteSpace($PORT)) { $PORT = "1433" }
          $DEPLOYED = 0
          
          $files = Get-Content '_changed_drop.txt' | Where-Object { $_.Trim() }
          foreach ($file in $files) {
            $trimmedFile = $file.Trim()
            if (Test-Path $trimmedFile) {
              Write-Host ""
              Write-Host "[DEPLOY DROP] $trimmedFile"
              $fullPath = Resolve-Path $trimmedFile
              
              $sqlcmdArgs = @(
                "-S", "$env:H,$PORT",
                "-d", "$env:D", 
                "-U", "$env:U",
                "-P", "$env:W",
                "-b", "-C",
                "-i", "`"$fullPath`""
              )
              
              $process = Start-Process -FilePath $env:SQLCMD_EXE -ArgumentList $sqlcmdArgs -Wait -PassThru -NoNewWindow
              
              if ($process.ExitCode -eq 0) {
                Write-Host "[SUCCESS] $trimmedFile"
                $DEPLOYED++
              } else {
                Write-Error "Failed to deploy: $trimmedFile"
                exit 1
              }
            } else {
              Write-Error "File not found: $trimmedFile"
              exit 1
            }
          }
          Write-Host "Deployed $DEPLOYED DROP file(s)"