name: PR → Validate & Deploy to STAGING

on:
  pull_request:
    paths:
      - "deploy/**/*.sql"
      - "rules.yml"
      - ".github/**"

permissions:
  contents: read
  pull-requests: write
  issues: write

defaults:
  run:
    shell: powershell

jobs:
  validate_and_deploy:
    runs-on: [self-hosted, Windows]
    environment: staging

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve sqlcmd
        run: |
          $ErrorActionPreference='Stop'
          $sqlcmdPaths = @(
            "${{ vars.SQLCMD_EXE }}",
            "C:\Program Files\SqlCmd\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          )
          $sqlcmd = $sqlcmdPaths | Where-Object { $_ -and (Test-Path $_) } | Select-Object -First 1
          if (!$sqlcmd) { try { $sqlcmd = (where.exe sqlcmd 2>$null) } catch {} }
          if (!$sqlcmd) { throw "sqlcmd.exe not found" }
          Write-Host ("Using sqlcmd: " + $sqlcmd)
          Add-Content -Path $env:GITHUB_ENV -Value ("SQLCMD_EXE=" + $sqlcmd)

      - name: Test database connection
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          $ErrorActionPreference='Stop'
          $PORT = if ($env:P) { $env:P } else { "1433" }
          Write-Host ("Testing connection to {0},{1}..." -f $env:H,$PORT)
          $ok = Test-NetConnection -ComputerName $env:H -Port $PORT -InformationLevel Quiet -WarningAction SilentlyContinue
          if (!$ok) { throw "Cannot reach database host" }
          & $env:SQLCMD_EXE -S "$env:H,$PORT" -d $env:D -U $env:U -P $env:W -l 10 -b -C -Q "SELECT 1"
          if ($LASTEXITCODE -ne 0) { throw "Database login failed" }
          Write-Host "Database connection successful"

      - name: Detect changed projects
        id: detect_projects
        run: |
          $ErrorActionPreference='Stop'
          git config --global --add safe.directory "$env:GITHUB_WORKSPACE" 2>$null
          try { git fetch origin --depth=100 2>$null; git fetch --all --tags --prune 2>$null } catch {}

          $base = '${{ github.base_ref }}'
          if ($base) {
            try { git fetch origin "${base}:refs/remotes/origin/$base" --depth=100 2>$null } catch {}
            $range = "origin/$base...HEAD"
          } else {
            $before = '${{ github.event.before }}'
            if ([string]::IsNullOrWhiteSpace($before) -or $before -match '^0+$') { $range = 'HEAD~1...HEAD' } else { $range = "$before...HEAD" }
          }
          Write-Host ('Git diff range: ' + $range)

          $changedFiles   = git -c core.quotepath=false diff --name-only --diff-filter=AMR $range -- "deploy/**/*.sql" 2>$null
          $untrackedFiles = git ls-files -mo --exclude-standard -- "deploy/**/*.sql" 2>$null

          $allFiles = @()
          if ($changedFiles) { $allFiles += $changedFiles }
          if ($untrackedFiles) { $allFiles += $untrackedFiles }
          $allFiles = $allFiles | Where-Object { $_ -and (Test-Path $_) } | Sort-Object -Unique

          if ($allFiles.Count -eq 0) {
            Write-Host 'No SQL files changed in deploy/.'
            Add-Content -Path $env:GITHUB_OUTPUT -Value "projects="
            Add-Content -Path $env:GITHUB_OUTPUT -Value "has_changes=false"
            exit 0
          }

          $projects = @{ }
          foreach ($file in $allFiles) {
            if ($file -match '^deploy/([^/]+)/') {
              $proj = $Matches[1]
              if (-not $projects.ContainsKey($proj)) { $projects[$proj] = @() }
              $projects[$proj] += $file
            }
          }

          Write-Host ''
          Write-Host '========================================='
          Write-Host 'CHANGED PROJECTS DETECTED'
          Write-Host '========================================='
          foreach ($p in $projects.Keys | Sort-Object) {
            Write-Host ('- ' + $p + ' (' + ($projects[$p].Count) + ' files)')
            $projects[$p] | Sort-Object | ForEach-Object { Write-Host ('   - ' + $_) }
          }
          Write-Host '========================================='

          $projectList = ($projects.Keys | Sort-Object) -join ','
          Add-Content -Path $env:GITHUB_OUTPUT -Value ("projects=" + $projectList)
          Add-Content -Path $env:GITHUB_OUTPUT -Value "has_changes=true"

          foreach ($p in $projects.Keys) {
            $projects[$p] | Set-Content ("_changed_" + $p + ".txt") -Encoding UTF8
          }

      - name: Load validation rules
        id: load_rules
        if: steps.detect_projects.outputs.has_changes == 'true'
        run: |
          $ErrorActionPreference='Stop'
          if (-not (Test-Path "rules.yml")) {
            Write-Host "rules.yml not found, using basic validation"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "rules_loaded=false"
            exit 0
          }

          Write-Host "Loading validation rules from rules.yml..."

          function Convert-Scalar($s) {
            if ($null -eq $s) { return "" }
            $t = $s.Trim()
            if ($t -match '^(?i:true|false)$') { return [bool]::Parse($t) }
            if ($t -match '^-?\d+(\.\d+)?$')   { return [double]$t }
            return $t.Trim(" '""")
          }

          $text  = Get-Content "rules.yml" -Raw -Encoding UTF8 -ErrorAction Stop
          $lines = $text -split "\r?\n"

          $root  = [ordered]@{}
          $stack = New-Object System.Collections.Stack
          $stack.Push(@{ indent = -1; node = $root; key = $null; container = $null })

          foreach ($raw in $lines) {
            if ($null -eq $raw) { continue }
            $trim = $raw.Trim()
            if ($trim -eq "" -or $trim.StartsWith("#")) { continue }

            $indentMatch = [regex]::Match($raw, '^( *)')
            $indent = $indentMatch.Groups[1].Value.Length
            while ($stack.Count -gt 0 -and $indent -le $stack.Peek().indent) { [void]$stack.Pop() }
            $parent = $stack.Peek()

            if ($trim.StartsWith("- ")) {
              $rest = $trim.Substring(2).Trim()
              if (-not ($parent.node -is [System.Collections.IList])) {
                if ($null -ne $parent.key -and $null -ne $parent.container) {
                  $parent.container[$parent.key] = New-Object System.Collections.ArrayList
                  $parent.node = $parent.container[$parent.key]
                } else {
                  $a = New-Object System.Collections.ArrayList
                  $parent.node = $a
                }
              }
              $colonPattern = '^\s*(.+?)\s*:\s*(.+)$'
              if ($rest -match $colonPattern) {
                $item = [ordered]@{}
                $item[$Matches[1].Trim()] = Convert-Scalar $Matches[2]
              } elseif ($rest.Length -gt 0) {
                $item = Convert-Scalar $rest
              } else {
                $item = [ordered]@{}
              }
              [void]$parent.node.Add($item)
              if ($item -is [hashtable]) {
                $stack.Push(@{ indent = $indent; node = $item; key = $null; container = $parent.node })
              }
              continue
            }

            $kv = $trim -split ':', 2
            if ($kv.Count -lt 2) { continue }
            $key = $kv[0].Trim(" '""")
            $val = $kv[1].Trim(" '""")

            if ($parent.node -is [System.Collections.IList]) {
              $last = $parent.node[$parent.node.Count-1]
              if (-not ($last -is [hashtable])) {
                $last = [ordered]@{}
                [void]$parent.node.Add($last)
              }
              if ($val -eq '') {
                $last[$key] = [ordered]@{}
                $stack.Push(@{ indent = $indent; node = $last[$key]; key = $key; container = $last })
              } else {
                $last[$key] = Convert-Scalar $val
              }
            } else {
              if ($val -eq '') {
                $parent.node[$key] = [ordered]@{}
                $stack.Push(@{ indent = $indent; node = $parent.node[$key]; key = $key; container = $parent.node })
              } else {
                $parent.node[$key] = Convert-Scalar $val
              }
            }
          }

          function As-Array($v) {
            if ($null -eq $v) { return @() }
            if ($v -is [System.Collections.IList]) { return $v }
            return @($v)
          }
          function Get-Path($obj, [string]$path, $default=$null) {
            $cur = $obj
            foreach ($p in $path -split '\.') {
              if ($null -eq $cur) { return $default }
              if ($cur -is [System.Collections.IDictionary]) {
                if (-not $cur.Contains($p)) { return $default }
                $cur = $cur[$p]
              } else { return $default }
            }
            if ($null -eq $cur) { return $default } else { return $cur }
          }

          $normalized = [ordered]@{
            type_guards = @{
              create = @{
                enabled = [bool](Get-Path $root 'type_guards.create.enabled' $false)
                rules   = As-Array (Get-Path $root 'type_guards.create.disallowed_patterns' @())
              }
              alter = @{
                enabled = [bool](Get-Path $root 'type_guards.alter.enabled' $false)
                rules   = As-Array (Get-Path $root 'type_guards.alter.disallowed_patterns' @())
              }
              drop = @{
                enabled = [bool](Get-Path $root 'type_guards.drop.enabled' $false)
                rules   = @()
              }
              procedure = @{
                enabled = [bool](Get-Path $root 'type_guards.procedure.enabled' $false)
                rules   = As-Array (Get-Path $root 'type_guards.procedure.disallowed_patterns' @())
              }
            }
            naming_conventions = @{
              enabled = [bool](Get-Path $root 'naming_conventions.enabled' $false)
              tables  = @{
                pattern = "" + (Get-Path $root 'naming_conventions.tables.pattern' "")
                message = "" + (Get-Path $root 'naming_conventions.tables.message' "")
              }
              columns = @{
                pattern = "" + (Get-Path $root 'naming_conventions.columns.pattern' "")
                message = "" + (Get-Path $root 'naming_conventions.columns.message' "")
              }
              procedures = @{
                pattern = "" + (Get-Path $root 'naming_conventions.procedures.pattern' "")
                message = "" + (Get-Path $root 'naming_conventions.procedures.message' "")
              }
            }
            performance_checks = @{
              enabled = [bool](Get-Path $root 'performance_checks.enabled' $false)
              rules   = As-Array (Get-Path $root 'performance_checks.rules' @())
            }
            security_checks = @{
              enabled = [bool](Get-Path $root 'security_checks.enabled' $false)
              rules   = As-Array (Get-Path $root 'security_checks.rules' @())
            }
            data_integrity = @{
              enabled = [bool](Get-Path $root 'data_integrity.enabled' $false)
              rules   = As-Array (Get-Path $root 'data_integrity.rules' @())
            }
            code_quality = @{
              enabled = [bool](Get-Path $root 'code_quality.enabled' $false)
              rules   = As-Array (Get-Path $root 'code_quality.rules' @())
            }
            custom_rules = @{
              enabled = [bool](Get-Path $root 'custom_rules.enabled' $false)
              rules   = As-Array (Get-Path $root 'custom_rules.rules' @())
            }
            bfi_custom_rules = @{
              enabled = [bool](Get-Path $root 'bfi_custom_rules.enabled' $false)
              rules   = As-Array (Get-Path $root 'bfi_custom_rules.rules' @())
            }
            deployment_safety = @{
              enabled = [bool](Get-Path $root 'deployment_safety.enabled' $true)
              rules   = As-Array (Get-Path $root 'deployment_safety.rules' @())
            }
          }

          $totalRules = 0
          $totalRules += $normalized.type_guards.create.rules.Count
          $totalRules += $normalized.type_guards.alter.rules.Count
          $totalRules += $normalized.type_guards.procedure.rules.Count
          $totalRules += $normalized.performance_checks.rules.Count
          $totalRules += $normalized.security_checks.rules.Count
          $totalRules += $normalized.data_integrity.rules.Count
          $totalRules += $normalized.code_quality.rules.Count
          $totalRules += $normalized.custom_rules.rules.Count
          $totalRules += $normalized.bfi_custom_rules.rules.Count
          $totalRules += $normalized.deployment_safety.rules.Count

          Write-Host ("Loaded " + $totalRules + " validation rules")
          Write-Host ("  - CREATE rules: " + $normalized.type_guards.create.rules.Count)
          Write-Host ("  - ALTER rules: " + $normalized.type_guards.alter.rules.Count)
          Write-Host ("  - PROCEDURE rules: " + $normalized.type_guards.procedure.rules.Count)
          Write-Host ("  - Performance checks: " + $normalized.performance_checks.rules.Count)
          Write-Host ("  - Security checks: " + $normalized.security_checks.rules.Count)
          Write-Host ("  - Data integrity: " + $normalized.data_integrity.rules.Count)
          Write-Host ("  - Code quality: " + $normalized.code_quality.rules.Count)
          Write-Host ("  - Custom rules: " + $normalized.custom_rules.rules.Count)
          Write-Host ("  - BFI custom rules: " + $normalized.bfi_custom_rules.rules.Count)
          Write-Host ("  - Deployment safety: " + $normalized.deployment_safety.rules.Count)

          ($normalized | ConvertTo-Json -Depth 50) | Set-Content "_validation_rules.json" -Encoding UTF8
          Add-Content -Path $env:GITHUB_OUTPUT -Value "rules_loaded=true"

      - name: Validate SQL files
        if: steps.detect_projects.outputs.has_changes == 'true'
        run: |
          $ErrorActionPreference='Stop'
          Write-Host ''
          Write-Host '========================================='
          Write-Host 'VALIDATING SQL FILES'
          Write-Host '========================================='

          if (!(Test-Path "_validation_rules.json")) {
            Write-Host 'Rules not loaded; using basic validation only'
            $rules = $null
          } else {
            $rules = Get-Content "_validation_rules.json" | ConvertFrom-Json
          }

          Add-Type -AssemblyName 'System.Core' | Out-Null
          $ROpts = [System.Text.RegularExpressions.RegexOptions]::IgnoreCase -bor `
                   [System.Text.RegularExpressions.RegexOptions]::Singleline -bor `
                   [System.Text.RegularExpressions.RegexOptions]::Multiline
          function Test-Pat([string]$s,[string]$p){ if([string]::IsNullOrEmpty($p)){ $false } else { [regex]::IsMatch($s,$p,$ROpts) } }
          function Get-LastLine([string]$s){ ($s -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' } | Select-Object -Last 1) }

          function Format-RuleMessage($category,$r,$pat,$content) {
            $nm = if ($r.PSObject.Properties['name'] -and -not [string]::IsNullOrWhiteSpace($r.name)) { ''+$r.name } elseif ($pat) { 'Pattern ' + $pat } else { 'Unnamed rule' }
            $ms = if ($r.PSObject.Properties['message'] -and -not [string]::IsNullOrWhiteSpace($r.message)) { ''+$r.message } else { 'Rule triggered' }
            $sample = ''
            try {
              $m = [regex]::Match($content, ''+$pat, $ROpts)
              if ($m.Success) {
                $val = $m.Value
                if ($val.Length -gt 60) { $val = $val.Substring(0,60) + '…' }
                $sample = ' (match: "' + $val + '")'
              }
            } catch {}
            return ("{0} | {1} — {2}{3}" -f $category,$nm,$ms,$sample)
          }

          $projects = '${{ steps.detect_projects.outputs.projects }}'.Split(',') | Where-Object { $_ }
          $validationFailed = $false
          $totalErrors = 0
          $totalWarnings = 0

          foreach ($proj in $projects) {
            $fileList = "_changed_" + $proj + ".txt"
            if (!(Test-Path $fileList)) { continue }
            Write-Host ''
            Write-Host ("Validating project: " + $proj)
            $files = Get-Content $fileList
            foreach ($file in $files) {
              $file = $file.Trim()
              if (!(Test-Path $file)) { continue }
              $content = Get-Content $file -Raw
              Write-Host ("  Checking: " + $file)

              $errors = @()
              $warnings = @()

              $isCreate = Test-Pat $content '\bCREATE\s+(TABLE|PROCEDURE|FUNCTION|VIEW)\b'
              $isAlter  = Test-Pat $content '\bALTER\s+(TABLE|PROCEDURE|FUNCTION|VIEW)\b'
              $isProcedure = Test-Pat $content '\bCREATE\s+PROCEDURE\b'

              if ($rules) {
                function Apply-RuleSet($ruleList, $content, [string]$category) {
                  $e = @(); $w = @()
                  foreach ($r in $ruleList) {
                    $pat = '' + $r.pattern
                    if ([string]::IsNullOrEmpty($pat)) { continue }
                    $matched = $false
                    try { $matched = [regex]::IsMatch($content,$pat,$ROpts) } catch { $matched = $false }
                    if (-not $matched) { continue }

                    $sev = ('' + $r.severity)
                    if ([string]::IsNullOrEmpty($sev)) { $sev = 'warning' } else { $sev = $sev.ToString().ToLower() }

                    $msg = Format-RuleMessage $category $r $pat $content
                    if ($sev -eq 'error') { $e += $msg } else { $w += $msg }
                  }
                  return @($e, $w)
                }

                if ($rules.type_guards.create.enabled -and $isCreate) {
                  $result = Apply-RuleSet $rules.type_guards.create.rules $content "CREATE"
                  $errors += $result[0]; $warnings += $result[1]
                }

                if ($rules.type_guards.alter.enabled -and $isAlter) {
                  $result = Apply-RuleSet $rules.type_guards.alter.rules $content "ALTER"
                  $errors += $result[0]; $warnings += $result[1]
                  # safety net MAX
                  $contentNorm = ($content -replace '\s+', ' ')
                  if (Test-Pat $contentNorm '\b(?:n?varchar|varbinary)\s*\(\s*max\s*\)') {
                    $errors += 'ALTER | MAX data types — VARCHAR(MAX)/NVARCHAR(MAX)/VARBINARY(MAX) are not allowed'
                  }
                }

                if ($rules.type_guards.procedure.enabled -and $isProcedure) {
                  $result = Apply-RuleSet $rules.type_guards.procedure.rules $content "PROCEDURE"
                  $errors += $result[0]; $warnings += $result[1]
                }

                if ($rules.naming_conventions.enabled) {
                  if ($isCreate -and $rules.naming_conventions.tables.pattern) {
                    if ($content -match '(?i)CREATE\s+TABLE\s+(?:\[?([a-zA-Z0-9_]+)\]?\.)?\[?([a-zA-Z0-9_]+)\]?') {
                      $tableName = $Matches[2]
                      if (-not (Test-Pat $tableName $rules.naming_conventions.tables.pattern)) {
                        $warnings += ('NAMING | Table — ' + $rules.naming_conventions.tables.message + ' (found: ' + $tableName + ')')
                      }
                    }
                  }
                  if ($rules.naming_conventions.columns.pattern) {
                    $colMatches = [regex]::Matches($content,'(?i)(?:ADD|ALTER\s+COLUMN)\s+\[?([a-zA-Z0-9_]+)\]?\s+',$ROpts)
                    foreach ($m in $colMatches) {
                      $c = $m.Groups[1].Value
                      if (-not (Test-Pat $c $rules.naming_conventions.columns.pattern)) {
                        $warnings += ('NAMING | Column — ' + $rules.naming_conventions.columns.message + ' (found: ' + $c + ')')
                      }
                    }
                  }
                  if ($isProcedure -and $rules.naming_conventions.procedures.pattern) {
                    if ($content -match '(?i)CREATE\s+PROCEDURE\s+(?:\[?([a-zA-Z0-9_]+)\]?\.)?\[?([a-zA-Z0-9_]+)\]?') {
                      $procName = $Matches[2]
                      if (-not (Test-Pat $procName $rules.naming_conventions.procedures.pattern)) {
                        $warnings += ('NAMING | Procedure — ' + $rules.naming_conventions.procedures.message + ' (found: ' + $procName + ')')
                      }
                    }
                  }
                }

                if ($rules.performance_checks.enabled) {
                  $result = Apply-RuleSet $rules.performance_checks.rules $content "PERFORMANCE"
                  $errors += $result[0]; $warnings += $result[1]
                }
                if ($rules.security_checks.enabled) {
                  $result = Apply-RuleSet $rules.security_checks.rules $content "SECURITY"
                  $errors += $result[0]; $warnings += $result[1]
                }
                if ($rules.data_integrity.enabled) {
                  $result = Apply-RuleSet $rules.data_integrity.rules $content "DATA INTEGRITY"
                  $errors += $result[0]; $warnings += $result[1]
                }
                if ($rules.code_quality.enabled) {
                  $result = Apply-RuleSet $rules.code_quality.rules $content "CODE QUALITY"
                  $errors += $result[0]; $warnings += $result[1]
                }
                if ($rules.custom_rules.enabled) {
                  $result = Apply-RuleSet $rules.custom_rules.rules $content "CUSTOM"
                  $errors += $result[0]; $warnings += $result[1]
                }
                if ($rules.bfi_custom_rules.enabled) {
                  $result = Apply-RuleSet $rules.bfi_custom_rules.rules $content "BFI"
                  $errors += $result[0]; $warnings += $result[1]
                }

                if ($rules.deployment_safety.enabled) {
                  foreach ($r in $rules.deployment_safety.rules) {
                    $rname = if ($r.PSObject.Properties['name'] -and $r.name) { ''+$r.name } else { 'Deployment rule' }
                    $rmsg  = if ($r.PSObject.Properties['message'] -and $r.message) { ''+$r.message } else { 'Rule triggered' }

                    if ($rname -eq 'Missing GO terminator') {
                      $last = Get-LastLine $content
                      if (($last -ne $null) -and ($last.ToUpper() -ne 'GO')) {
                        $msg = 'DEPLOYMENT | ' + $rname + ' — ' + $rmsg
                        if ($r.severity -eq 'error') { $errors += $msg } else { $warnings += $msg }
                      }
                    } elseif ($r.pattern -and (Test-Pat $content ([string]$r.pattern))) {
                      $msg = 'DEPLOYMENT | ' + $rname + ' — ' + $rmsg
                      if ($r.severity -eq 'error') { $errors += $msg } else { $warnings += $msg }
                    }
                  }
                }
              } else {
                if (Test-Pat $content '\bDROP\s+DATABASE\b') { $errors += 'SECURITY | DROP DATABASE — not allowed' }
                if (Test-Pat $content '\bTRUNCATE\s+TABLE\b') { $errors += 'SECURITY | TRUNCATE TABLE — data loss risk' }
                if (Test-Pat $content '\bDROP\s+TABLE\b')     { $warnings += 'CUSTOM | DROP TABLE — review carefully' }
                $last = Get-LastLine $content
                if (($last -ne $null) -and ($last.ToUpper() -ne 'GO')) { $errors += 'DEPLOYMENT | Missing GO terminator — SQL file must end with GO' }
              }

              $fileWarn = 0; $fileErr = 0
              foreach ($w in $warnings) { Write-Host ('    [WARN] ' + $w) -ForegroundColor Yellow; $totalWarnings++; $fileWarn++ }
              if ($errors.Count -gt 0) {
                Write-Host '    [FAIL] Validation FAILED' -ForegroundColor Red
                foreach ($e in $errors) { Write-Host ('       - ' + $e) -ForegroundColor Red; $totalErrors++; $fileErr++ }
                $validationFailed = $true
              } else {
                Write-Host '    [OK] Validation PASSED' -ForegroundColor Green
              }
              Write-Host ("    Summary: {0} warning(s), {1} error(s)" -f $fileWarn,$fileErr)
            }
          }

          Write-Host ''
          Write-Host '========================================='
          Write-Host 'VALIDATION SUMMARY'
          Write-Host '========================================='
          Write-Host ('Total errors: ' + $totalErrors)
          Write-Host ('Total warnings: ' + $totalWarnings)
          if ($validationFailed) { 
            Write-Host 'Status: FAILED' -ForegroundColor Red
            Write-Host '========================================='
            throw 'Validation failed' 
          }
          Write-Host 'Status: PASSED' -ForegroundColor Green
          Write-Host '========================================='

      - name: Deploy to STAGING (per project)
        if: steps.detect_projects.outputs.has_changes == 'true'
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          $ErrorActionPreference='Stop'
          $PORT = if ($env:P) { $env:P } else { '1433' }

          Write-Host ''
          Write-Host '========================================='
          Write-Host 'DEPLOYING TO STAGING'
          Write-Host '========================================='

          $projects = '${{ steps.detect_projects.outputs.projects }}'.Split(',') | Where-Object { $_ }
          $totalDeployed = 0
          $deploymentLog = @()

          foreach ($proj in $projects) {
            Write-Host ''
            Write-Host ('Deploying project: ' + $proj) -ForegroundColor Cyan
            Write-Host '-----------------------------------------'
            $fileList = '_changed_' + $proj + '.txt'
            if (!(Test-Path $fileList)) { Write-Host '  No file list found, skipping'; continue }

            $files = Get-Content $fileList | Sort-Object
            $hasAlter = $false
            foreach ($f in $files) { if ((Get-Content $f -Raw) -match '(?i)\bALTER\s+TABLE\b') { $hasAlter = $true; break } }
            if ($hasAlter) { Write-Host '  Project contains ALTER - backup recommended' -ForegroundColor Yellow }

            foreach ($file in $files) {
              $file = $file.Trim()
              if (!(Test-Path $file)) { 
                Write-Host ('  FAILED: File not found: ' + $file) -ForegroundColor Red
                throw ('Deployment failed: file not found ' + $file) 
              }
              $fileName = Split-Path $file -Leaf
              Write-Host ('  Deploying: ' + $fileName)

              $fullPath = Resolve-Path $file
              $args = @('-S', ("{0},{1}" -f $env:H, $PORT), '-d', $env:D, '-U', $env:U, '-P', $env:W, '-b', '-C', '-i', $fullPath)

              & $env:SQLCMD_EXE @args
              if ($LASTEXITCODE -ne 0) {
                Write-Host ('  FAILED: ' + $fileName + ' (exit ' + $LASTEXITCODE + ')') -ForegroundColor Red
                throw ('Deployment failed for ' + $fileName)
              }

              Write-Host ('  SUCCESS: ' + $fileName) -ForegroundColor Green
              $totalDeployed++
              $deploymentLog += @{ project=$proj; file=$fileName; status='success'; timestamp=(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') }
            }

            $countProj = (($deploymentLog | Where-Object { $_.project -eq $proj }).Count)
            Write-Host ('  Project "' + $proj + '": deployed ' + $countProj + ' file(s)') -ForegroundColor Cyan
          }

          Write-Host ''
          Write-Host '========================================='
          Write-Host 'DEPLOYMENT SUMMARY'
          Write-Host '========================================='
          Write-Host ('Total projects: ' + $projects.Count)
          Write-Host ('Total files deployed: ' + $totalDeployed)
          Write-Host 'Status: SUCCESS' -ForegroundColor Green
          Write-Host '========================================='

          $deploymentLog | ConvertTo-Json | Set-Content 'deployment_log.json' -Encoding UTF8

      - name: Upload deployment artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: staging-deployment-logs
          path: |
            _changed_*.txt
            _validation_rules.json
            deployment_log.json
          if-no-files-found: ignore

      - name: Comment on PR
        if: always() && steps.detect_projects.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const projects = '${{ steps.detect_projects.outputs.projects }}'.split(',').filter(Boolean);
            let status = '${{ job.status }}' === 'success' ? '✅ SUCCESS' : '❌ FAILED';
            let comment = '## Staging Deployment Report\n\n';
            comment += `**Status:** ${status}\n`;
            comment += `**Environment:** STAGING\n`;
            comment += `**Projects deployed:** ${projects.length}\n\n`;
            comment += '### Projects\n\n';
            for (const proj of projects) {
              comment += `#### ${proj}\n\n`;
              const fileList = `_changed_${proj}.txt`;
              if (fs.existsSync(fileList)) {
                const files = fs.readFileSync(fileList, 'utf8').trim().split('\n').filter(Boolean);
                comment += '| File | Status |\n|------|--------|\n';
                for (const f of files) {
                  const fileName = f.split('/').pop();
                  const icon = '${{ job.status }}' === 'success' ? '✅' : '❌';
                  comment += `| \`${fileName}\` | ${icon} |\n`;
                }
                comment += '\n';
              }
            }
            comment += '\n---\n';
            comment += `_Deployed at ${new Date().toISOString()}_`;
            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } catch (e) {
              core.warning(`Skipping PR comment: ${e.message}`);
            }