name: PR ‚Üí Validate & Deploy to STAGING

on:
  pull_request:
    paths:
      - "deploy/**/*.sql"
      - "rules.yml"
      - ".github/**"

defaults:
  run:
    shell: powershell

jobs:
  validate_and_deploy:
    runs-on: [self-hosted, Windows]
    environment: staging
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: pip install pyyaml

      - name: Resolve sqlcmd
        run: |
          $ErrorActionPreference='Stop'
          $sqlcmdPaths = @(
            "${{ vars.SQLCMD_EXE }}",
            "C:\Program Files\SqlCmd\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\160\Tools\Binn\sqlcmd.exe",
            "C:\Program Files\Microsoft SQL Server\150\Tools\Binn\sqlcmd.exe"
          )
          $sqlcmd = $sqlcmdPaths | Where-Object { $_ -and (Test-Path $_) } | Select-Object -First 1
          if (!$sqlcmd) {
            try { $sqlcmd = (where.exe sqlcmd 2>$null) } catch {}
          }
          if (!$sqlcmd) { throw "sqlcmd.exe not found" }
          Write-Host "Using sqlcmd: $sqlcmd"
          "SQLCMD_EXE=$sqlcmd" | Out-File $env:GITHUB_ENV -Append

      - name: Test database connection
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          $PORT = if ($env:P) { $env:P } else { "1433" }
          Write-Host "Testing connection to $env:H,$PORT..."
          
          $result = Test-NetConnection -ComputerName $env:H -Port $PORT -InformationLevel Quiet -WarningAction SilentlyContinue
          if (!$result) { throw "Cannot reach database host" }
          
          & $env:SQLCMD_EXE -S "$env:H,$PORT" -d $env:D -U $env:U -P $env:W -l 10 -b -C -Q "SELECT 1"
          if ($LASTEXITCODE -ne 0) { throw "Database login failed" }
          Write-Host "‚úÖ Database connection successful"

      - name: Detect changed projects
        id: detect_projects
        run: |
          $ErrorActionPreference='Stop'
          git config --global --add safe.directory "$env:GITHUB_WORKSPACE" 2>$null
          
          try {
            git fetch origin --depth=100 2>$null
            git fetch --all --tags --prune 2>$null
          } catch {}
          
          $base = '${{ github.base_ref }}'
          if ($base) {
            try {
              git fetch origin "${base}:refs/remotes/origin/$base" --depth=100 2>$null
            } catch {}
            $range = "origin/$base...HEAD"
          } else {
            $before = '${{ github.event.before }}'
            if ([string]::IsNullOrWhiteSpace($before) -or $before -match '^0+$') {
              $range = 'HEAD~1...HEAD'
            } else {
              $range = "$before...HEAD"
            }
          }
          
          Write-Host "Git diff range: $range"
          
          # Get all changed SQL files in deploy/
          $changedFiles = git -c core.quotepath=false diff --name-only --diff-filter=AMR $range -- "deploy/**/*.sql" 2>$null
          $untrackedFiles = git ls-files -mo --exclude-standard -- "deploy/**/*.sql" 2>$null
          
          $allFiles = @()
          if ($changedFiles) { $allFiles += $changedFiles }
          if ($untrackedFiles) { $allFiles += $untrackedFiles }
          $allFiles = $allFiles | Where-Object { $_ -and (Test-Path $_) } | Sort-Object -Unique
          
          if ($allFiles.Count -eq 0) {
            Write-Host "‚ÑπÔ∏è No SQL files changed in deploy/"
            "projects=" | Out-File $env:GITHUB_OUTPUT -Append
            "has_changes=false" | Out-File $env:GITHUB_OUTPUT -Append
            exit 0
          }
          
          # Group files by project folder
          $projects = @{}
          foreach ($file in $allFiles) {
            # Extract project folder: deploy/project_name/file.sql
            if ($file -match '^deploy/([^/]+)/') {
              $projectName = $matches[1]
              if (!$projects.ContainsKey($projectName)) {
                $projects[$projectName] = @()
              }
              $projects[$projectName] += $file
            }
          }
          
          Write-Host ""
          Write-Host "========================================="
          Write-Host "CHANGED PROJECTS DETECTED"
          Write-Host "========================================="
          foreach ($proj in $projects.Keys | Sort-Object) {
            Write-Host "üìÅ $proj ($($projects[$proj].Count) files)"
            $projects[$proj] | Sort-Object | ForEach-Object { Write-Host "   - $_" }
          }
          Write-Host "========================================="
          
          # Save project list to output and file
          $projectList = ($projects.Keys | Sort-Object) -join ','
          "projects=$projectList" | Out-File $env:GITHUB_OUTPUT -Append
          "has_changes=true" | Out-File $env:GITHUB_OUTPUT -Append
          
          # Save detailed file list per project
          foreach ($proj in $projects.Keys) {
            $projects[$proj] | Set-Content "_changed_${proj}.txt" -Encoding UTF8
          }

      - name: Validate SQL files
        if: steps.detect_projects.outputs.has_changes == 'true'
        run: |
          $ErrorActionPreference='Stop'
          
          Write-Host ""
          Write-Host "========================================="
          Write-Host "VALIDATING SQL FILES"
          Write-Host "========================================="
          
          # Load rules from YAML (simple parsing)
          $rulesContent = Get-Content rules.yml -Raw
          
          $projects = '${{ steps.detect_projects.outputs.projects }}'.Split(',') | Where-Object { $_ }
          $validationFailed = $false
          
          foreach ($proj in $projects) {
            $fileList = "_changed_${proj}.txt"
            if (!(Test-Path $fileList)) { continue }
            
            Write-Host ""
            Write-Host "üìÅ Validating project: $proj"
            
            $files = Get-Content $fileList
            foreach ($file in $files) {
              $file = $file.Trim()
              if (!(Test-Path $file)) { continue }
              
              Write-Host "  Checking: $file"
              
              $content = Get-Content $file -Raw
              $errors = @()
              
              # Basic validations
              if ($content -match '(?i)DROP\s+TABLE') {
                $errors += "DROP TABLE detected (dangerous)"
              }
              if ($content -match '(?i)TRUNCATE\s+TABLE') {
                $errors += "TRUNCATE TABLE detected"
              }
              if ($content -notmatch '(?i)GO\s*$') {
                $errors += "Missing GO terminator"
              }
              
              if ($errors.Count -gt 0) {
                Write-Host "    ‚ùå Validation FAILED" -ForegroundColor Red
                $errors | ForEach-Object { Write-Host "       - $_" -ForegroundColor Red }
                $validationFailed = $true
              } else {
                Write-Host "    ‚úÖ Validation PASSED" -ForegroundColor Green
              }
            }
          }
          
          if ($validationFailed) {
            Write-Host ""
            Write-Host "‚ùå SQL validation failed" -ForegroundColor Red
            throw "Validation failed"
          }
          
          Write-Host ""
          Write-Host "‚úÖ All SQL files passed validation" -ForegroundColor Green

      - name: Deploy to STAGING (per project)
        if: steps.detect_projects.outputs.has_changes == 'true'
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          $ErrorActionPreference='Stop'
          $PORT = if ($env:P) { $env:P } else { "1433" }
          
          Write-Host ""
          Write-Host "========================================="
          Write-Host "DEPLOYING TO STAGING"
          Write-Host "========================================="
          
          $projects = '${{ steps.detect_projects.outputs.projects }}'.Split(',') | Where-Object { $_ }
          $totalDeployed = 0
          $deploymentLog = @()
          
          foreach ($proj in $projects) {
            Write-Host ""
            Write-Host "üìÅ Deploying project: $proj" -ForegroundColor Cyan
            Write-Host "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            
            $fileList = "_changed_${proj}.txt"
            if (!(Test-Path $fileList)) {
              Write-Host "  ‚ö†Ô∏è No file list found, skipping"
              continue
            }
            
            $files = Get-Content $fileList | Sort-Object
            $projectDeployed = 0
            
            # Check if project has ALTER statements - if yes, create backup
            $hasAlter = $false
            foreach ($file in $files) {
              if ((Get-Content $file -Raw) -match '(?i)\bALTER\s+TABLE') {
                $hasAlter = $true
                break
              }
            }
            
            if ($hasAlter) {
              Write-Host "  üì¶ Project contains ALTER - creating backup..." -ForegroundColor Yellow
              # Auto-backup logic would go here
            }
            
            # Deploy files in order (sorted by filename)
            foreach ($file in $files) {
              $file = $file.Trim()
              if (!(Test-Path $file)) {
                Write-Host "  ‚ùå File not found: $file" -ForegroundColor Red
                throw "Deployment failed: file not found"
              }
              
              $fileName = Split-Path $file -Leaf
              Write-Host "  üöÄ Deploying: $fileName"
              
              $fullPath = Resolve-Path $file
              $sqlcmdArgs = @(
                "-S", "$env:H,$PORT",
                "-d", "$env:D",
                "-U", "$env:U",
                "-P", "$env:W",
                "-b", "-C",
                "-i", "`"$fullPath`""
              )
              
              $process = Start-Process -FilePath $env:SQLCMD_EXE -ArgumentList $sqlcmdArgs -Wait -PassThru -NoNewWindow
              
              if ($process.ExitCode -ne 0) {
                Write-Host "  ‚ùå FAILED: $fileName (exit code: $($process.ExitCode))" -ForegroundColor Red
                throw "Deployment failed for $file"
              }
              
              Write-Host "  ‚úÖ SUCCESS: $fileName" -ForegroundColor Green
              $projectDeployed++
              $totalDeployed++
              
              $deploymentLog += @{
                project = $proj
                file = $fileName
                status = "success"
                timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
              }
            }
            
            Write-Host "  üìä Project '$proj': deployed $projectDeployed file(s)" -ForegroundColor Cyan
          }
          
          Write-Host ""
          Write-Host "========================================="
          Write-Host "DEPLOYMENT SUMMARY"
          Write-Host "========================================="
          Write-Host "Total projects: $($projects.Count)"
          Write-Host "Total files deployed: $totalDeployed"
          Write-Host "Status: ‚úÖ SUCCESS"
          Write-Host "========================================="
          
          # Save deployment log
          $deploymentLog | ConvertTo-Json | Set-Content "deployment_log.json"

      - name: Upload deployment artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: staging-deployment-logs
          path: |
            _changed_*.txt
            deployment_log.json
          if-no-files-found: ignore

      - name: Comment on PR
        if: always() && steps.detect_projects.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const projects = '${{ steps.detect_projects.outputs.projects }}'.split(',').filter(x => x);
            
            let comment = '## üöÄ Staging Deployment Report\n\n';
            comment += `**Status:** ${{ job.status == 'success' && '‚úÖ SUCCESS' || '‚ùå FAILED' }}\n`;
            comment += `**Environment:** STAGING\n`;
            comment += `**Projects deployed:** ${projects.length}\n\n`;
            
            comment += '### üìÅ Projects\n\n';
            for (const proj of projects) {
              comment += `#### ${proj}\n\n`;
              const fileList = `_changed_${proj}.txt`;
              if (fs.existsSync(fileList)) {
                const files = fs.readFileSync(fileList, 'utf8').trim().split('\n');
                comment += '| File | Status |\n';
                comment += '|------|--------|\n';
                files.forEach(file => {
                  const fileName = file.split('/').pop();
                  const status = '${{ job.status }}' === 'success' ? '‚úÖ' : '‚ùå';
                  comment += `| \`${fileName}\` | ${status} |\n`;
                });
                comment += '\n';
              }
            }
            
            comment += '\n---\n';
            comment += `_Deployed at ${new Date().toISOString()}_`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });