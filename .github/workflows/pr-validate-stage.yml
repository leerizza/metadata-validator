name: Validate & Deploy to STAGING

on:
  pull_request:
    paths:
      - "tables/**/*.yml"
      - "tables/**/*.yaml"
      - "deploy/**/*.sql"
      - "rules.yml"
      - "validate_sql.py"
      - "scripts/**"
      - ".github/workflows/**"

concurrency:
  group: pr-${{ github.event.pull_request.number || github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

defaults:
  run:
    shell: cmd

jobs:
  validate:
    runs-on: [self-hosted, Windows]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # - name: Resolve Python and create venv
      #   run: |
      #     where python || (echo ❌ Python not found & exit /b 1)
      #     for /f "delims=" %%i in ('where python') do (
      #       echo %%i | findstr /i "\\WindowsApps\\" >nul && (rem skip) || (set "PYTHON_EXE=%%i" & goto :found)
      #     )
      #     :found
      #     "%PYTHON_EXE%" -m venv .venv
      #     set "VENV_PY=%CD%\.venv\Scripts\python.exe"
      #     echo VENV_PY=%VENV_PY%>>%GITHUB_ENV%


      # (opsional) type-guard sederhana: larang MAX & legacy LOB
      - name: Block disallowed types (no MAX, no legacy LOB)
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $files = Get-ChildItem -Path 'deploy' -Filter '*.sql' -Recurse -ErrorAction SilentlyContinue
          if (-not $files) { Write-Host 'No SQL files.'; exit 0 }
          $patMax    = '\b(?:n?varchar|varbinary)\s*\(\s*max\s*\)'
          $patLegacy = '\b(?:text|ntext|image)\b'
          $bad    = Select-String -Path $files.FullName -Pattern $patMax
          $legacy = Select-String -Path $files.FullName -Pattern $patLegacy
          if (($bad | Measure-Object).Count -gt 0 -or ($legacy | Measure-Object).Count -gt 0) {
            Write-Host 'Found disallowed type(s):'
            if ($bad)    { ($bad.Path    | Sort-Object -Unique) | ForEach-Object { " - $_" } }
            if ($legacy) { ($legacy.Path | Sort-Object -Unique) | ForEach-Object { " - $_" } }
            exit 1
          }
          Write-Host 'SQL type validation passed.'

      # - name: Install SQLFluff (Windows)
      #   # defaults.run.shell sudah cmd, jadi cukup pakai cmd
      #   run: |
      #     if not exist "%VENV_PY%" (
      #       echo VENV_PY not set, fallback to PYTHON_EXE
      #       set "VENV_PY=%PYTHON_EXE%"
      #     )
      #     "%VENV_PY%" -m pip install --upgrade pip
      #     "%VENV_PY%" -m pip install sqlfluff

      
      # - name: Lint SQL scripts with SQLFluff
      #   run: |
      #     if not exist "%VENV_PY%" set "VENV_PY=%PYTHON_EXE%"
      #     rem Dialect SQL Server
      #     "%VENV_PY%" -m sqlfluff lint deploy --dialect tsql --format github-annotation-native --nocolor

      
      # - name: Auto-fix SQL formatting (optional)
      #   if: always()
      #   run: |
      #     if not exist "%VENV_PY%" set "VENV_PY=%PYTHON_EXE%"
      #     "%VENV_PY%" -m sqlfluff fix deploy --dialect tsql --force



  deploy_staging:
    needs: validate
    runs-on: [self-hosted, Windows]
    environment: staging   # ← secrets staging, tanpa approval
    steps:
      - uses: actions/checkout@v4

      - name: Prepare logs folder
        shell: powershell
        run: |
          $root = Join-Path $env:GITHUB_WORKSPACE 'deploy_logs'
          if (!(Test-Path $root)) { New-Item -ItemType Directory -Path $root -Force | Out-Null }
          "LOGDIR=$root" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii

      - name: Ensure sqlcmd path
        run: |
          echo SQLCMD_EXE=${{ vars.SQLCMD_EXE }}>>%GITHUB_ENV%
          if not exist "%SQLCMD_EXE%" (
            echo ❌ sqlcmd not found at %SQLCMD_EXE%
            exit /b 1
          )

       # Preflight — tampilkan target
      - name: Echo target
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          if "%H%"=="" ( echo ❌ Secret STG_DB_HOST kosong & exit /b 1 )
          echo Using sqlcmd: %SQLCMD_EXE%
          echo Target: %H%,%PORT% / DB=%D%

      # Preflight — DNS
      - name: DNS resolve
        env:
          H: ${{ secrets.STG_DB_HOST }}
        run: nslookup %H% || (echo ❌ DNS FAILED & exit /b 1)

      # Preflight — TCP
      - name: TCP port check
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          echo Checking TCP connection to %H%:%PORT% ...
          powershell -Command "if(!(Test-NetConnection -ComputerName '%H%' -Port ([int]'%PORT%') -InformationLevel Quiet)){exit 1}"

      - name: Test sqlcmd login (SELECT 1)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -l 10 -b -C -Q "SELECT 1"

      - name: Compute changed SQL (robust)
        id: changes
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          Set-Location "$env:GITHUB_WORKSPACE"
          git config --global --add safe.directory "$env:GITHUB_WORKSPACE" 2>$null

          # Fetch all refs
          try {
            git fetch --all --tags --prune 2>$null
          } catch {
            Write-Host "::warning title=git fetch failed::Retrying with 'origin --prune'"
            try { git fetch origin --prune 2>$null } catch { Write-Host "::warning title=git fetch still failed::Using local range only." }
          }

          $eventName = '${{ github.event_name }}'
          $beforeSha = '${{ github.event.before }}'
          $baseRef   = '${{ github.base_ref }}'

          if ($eventName -eq 'pull_request' -and $baseRef) {
            Write-Host "🔄 Fetching base branch origin/$baseRef ..."
            try {
              git fetch origin "$($baseRef):$($baseRef)" --depth=1 2>$null
            } catch {
              Write-Host "::warning title=Fetch base_ref failed::Will fallback to local HEAD~1"
            }
            if ((git rev-parse --verify $baseRef 2>$null) -and $LASTEXITCODE -eq 0) {
              $range = "$baseRef...HEAD"
            } else {
              $range = 'HEAD~1...HEAD'
            }
          }
          else {
            if ([string]::IsNullOrWhiteSpace($beforeSha) -or $beforeSha -match '^0+$') {
              $range = 'HEAD~1...HEAD'
            } else {
              $range = "$beforeSha...HEAD"
            }
          }

          $changed = git diff --name-only --diff-filter=AMR $range -- "deploy/*.sql"
          $hasChanges = if ($changed) { 'true' } else { 'false' }

          if ($hasChanges -eq 'true') {
            $listFile = Join-Path $env:GITHUB_WORKSPACE 'deploy\_changed_sql.txt'
            $changed | Sort-Object | Set-Content -LiteralPath $listFile -Encoding UTF8
            "CHANGED_SQL_LIST=$listFile" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
            Write-Host "Changed SQL (range $range):"
            Get-Content $listFile | ForEach-Object { " - $_" }
          } else {
            Write-Host "No changed deploy SQL in range: $range"
            Write-Host "::notice title=No changed SQL::Skipping backup/deploy steps."
          }

          "has_changes=$hasChanges" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          if ($hasChanges -eq 'true') {
            "changed_list=deploy\_changed_sql.txt" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }


      
      - name: Filter to CREATE/ALTER TABLE (PR)
        if: steps.changes.outputs.has_changes == 'true'
        shell: powershell
        run: |
          $list = Get-Content $env:GITHUB_WORKSPACE\deploy\_changed_sql.txt
          $rx = [regex]'(?is)\b(?:create|alter)\s+table\b'
          $keep = @()
          foreach ($f in $list) { if (Test-Path $f) { $t = Get-Content $f -Raw; if ($rx.IsMatch($t)) { $keep += $f } } }
          if (-not $keep) {
            Write-Host "::notice title=No table DDL in changed SQL::Skipping backup/deploy."
            Remove-Item $env:GITHUB_WORKSPACE\deploy\_changed_sql.txt -ErrorAction SilentlyContinue
            exit 0
          }
          $keep | Sort-Object | Set-Content -LiteralPath $env:GITHUB_WORKSPACE\deploy\_changed_sql.txt -Encoding UTF8

      - name: Generate backup script (from changed SQL) - STAGING
        if: ${{ env.CHANGED_SQL_LIST != '' }}
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $ts = Get-Date -Format yyyyMMddHHmmss
          $suffix = "__bak_$ts"
          "BACKUP_SUFFIX=$suffix" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii

          $files = Get-Content $env:CHANGED_SQL_LIST
          $rx = [regex]'(?is)create\s+table\s+(?:\[?(?<schema>\w+)\]?\.)?\[?(?<table>\w+)\]?'
          $pairs = @()
          foreach ($f in $files) {
            if (Test-Path $f) {
              $content = Get-Content $f -Raw
              foreach ($m in $rx.Matches($content)) {
                $schema = if ($m.Groups['schema'].Success) { $m.Groups['schema'].Value } else { 'dbo' }
                $table  = $m.Groups['table'].Value
                if ($table) { $pairs += [PSCustomObject]@{ Schema=$schema; Table=$table } }
              }
            }
          }
          $pairs = $pairs | Sort-Object Schema,Table -Unique
          if (-not $pairs) { Write-Host 'No CREATE TABLE found in changed SQL'; exit 0 }

          $out = Join-Path $env:GITHUB_WORKSPACE ("deploy\__auto_backup_$ts.sql")
          $sb = New-Object System.Text.StringBuilder
          $null = $sb.AppendLine('-- auto-generated backup script (STAGING)')
          foreach ($p in $pairs) {
            $qn = '['+$p.Schema+'].['+$p.Table+']'
            $bk = '['+$p.Schema+'].['+$p.Table+$suffix+']'
            $null = $sb.AppendLine("IF OBJECT_ID(N'$qn','U') IS NOT NULL")
            $null = $sb.AppendLine("BEGIN")
            $null = $sb.AppendLine("  IF OBJECT_ID(N'$bk','U') IS NULL")
            $null = $sb.AppendLine("  BEGIN")
            $null = $sb.AppendLine("    SELECT * INTO $bk FROM $qn WITH (HOLDLOCK, TABLOCKX);")
            $null = $sb.AppendLine("  END")
            $null = $sb.AppendLine("END")
            $null = $sb.AppendLine("GO")
          }
          $sb.ToString() | Set-Content -LiteralPath $out -Encoding UTF8
          "BACKUP_SQL=$out" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
          Write-Host "Backup script: $out"

      - name: Run backup script (STAGING)
        if: ${{ env.BACKUP_SQL != '' }}
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          echo Running backup: %BACKUP_SQL%
          "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -b -C -i "%BACKUP_SQL%"
  

      - name: Deploy to STAGING (changed SQL only)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          set "PORT=%P%" & if "%PORT%"=="" set "PORT=1433"
          rem Prioritas: kalau ada daftar _changed_sql.txt, pakai itu.
          if exist deploy\_changed_sql.txt (
            for /f "usebackq delims=" %%F in (`type deploy\_changed_sql.txt`) do (
              if exist "%%F" (
                echo Executing %%~nxF ...
                "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -b -C -i "%%F"
                if errorlevel 1 exit /b 1
              )
            )
          ) else (
            echo No changed SQL list. Skipping deploy.
          )


      - name: Upload deploy logs
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: staging-deploy-logs
          path: |
            deploy_logs/**
            deploy/*.sql
          if-no-files-found: warn
