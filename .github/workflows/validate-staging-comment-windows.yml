name: Validate → Deploy STAGING → Comment PR (Windows Self-Hosted)

on:
  pull_request:
    paths:
      - "tables/**/*.yml"
      - "tables/**/*.yaml"
      - "deploy/**/*.sql"
      - "rules.yml"
      - "validate_sql.py"
      - "scripts/metadata_validate_and_render.py"
      - ".github/workflows/validate-staging-comment-windows.yml"

# Batalkan run lama untuk PR yang sama (hemat runner time)
concurrency:
  group: pr-${{ github.event.pull_request.number }}-validate
  cancel-in-progress: true

permissions:
  contents: read
  issues: write
  pull-requests: write

defaults:
  run:
    shell: cmd

jobs:
  validate:
    runs-on: [self-hosted, Windows]
    timeout-minutes: 20

    outputs:
      SKIP_DEPLOY: ${{ steps.short.outputs.skip }}

    steps:
      - uses: actions/checkout@v4

      # Deteksi perubahan relevan
      - name: Detect changed files
        id: cf
        uses: tj-actions/changed-files@v45
        with:
          files: |
            tables/**.yml
            tables/**.yaml
            deploy/**.sql
            rules.yml
            validate_sql.py
            scripts/metadata_validate_and_render.py

      - name: Short-circuit if nothing to validate
        id: short
        if: steps.cf.outputs.any_changed == 'false'
        run: |
          echo No relevant changes. Skipping validate.
          echo skip=true>>%GITHUB_OUTPUT%

      # ==== SETUP PYTHON CEPAT (cache venv + pip) ====
      - name: Resolve Python path (skip WindowsApps alias)
        if: steps.short.outputs.skip != 'true'
        run: |
          where python || (echo Python not found in PATH & exit /b 1)
          set "PY="
          for /f "delims=" %%i in ('where python') do (
            echo %%i | findstr /i "\\WindowsApps\\" >nul && (rem skip) || (
              set "PY=%%i"
              goto :found
            )
          )
          :found
          if "%PY%"=="" (echo No real python.exe found & exit /b 1)
          echo PYTHON_EXE=%PY%>>%GITHUB_ENV%

      - name: Cache pip/venv
        if: steps.short.outputs.skip != 'true'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            .venv
          key: ${{ runner.os }}-py311-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-py311-

      - name: Create venv and install deps
        if: steps.short.outputs.skip != 'true'
        run: |
          "%PYTHON_EXE%" --version
          if not exist .venv ("%PYTHON_EXE%" -m venv .venv)
          set "VENV_PY=%CD%\.venv\Scripts\python.exe"
          echo VENV_PY=%VENV_PY%>>%GITHUB_ENV%
          "%VENV_PY%" -m pip install --upgrade pip
          "%VENV_PY%" -m pip install -r requirements.txt

      # (opsional) validator lama
      - name: Run legacy validator (optional)
        if: steps.short.outputs.skip != 'true'
        continue-on-error: true
        env:
          PYTHONUTF8: "1"
          PYTHONIOENCODING: "UTF-8"
        run: |
          chcp 65001 >NUL
          "%VENV_PY%" -X utf8 validate_sql.py --junit report.xml

      # (opsional) kalau kamu masih generate SQL via Python, panggil di sini
      # - name: Generate CREATE TABLE from metadata
      #   if: steps.short.outputs.skip != 'true'
      #   run: |
      #     "%VENV_PY%" scripts/metadata_validate_and_render.py tables deploy

      - name: Upload generated SQL
        if: steps.short.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: generated-sql
          path: deploy/*.sql
          if-no-files-found: ignore

  deploy_staging:
    needs: validate
    if: needs.validate.outputs.SKIP_DEPLOY != 'true'
    runs-on: [self-hosted, Windows]
    environment: staging
    timeout-minutes: 20

    steps:
      - uses: actions/checkout@v4

      - name: Download generated SQL (if any)
        uses: actions/download-artifact@v4
        with:
          name: generated-sql
          path: deploy
        continue-on-error: true

      - name: Use sqlcmd path from repo variable
        run: |
          echo SQLCMD_EXE=${{ vars.SQLCMD_EXE }}>>%GITHUB_ENV%
          if not exist "${{ vars.SQLCMD_EXE }}" (
            echo sqlcmd.exe not found at: ${{ vars.SQLCMD_EXE }}
            exit /b 1
          )


      - name: Prepare logs folder
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          # lokasi default di bawah workspace
          $root = Join-Path $env:GITHUB_WORKSPACE 'deploy_logs'
          if (!(Test-Path -LiteralPath $root)) {
            New-Item -ItemType Directory -Path $root -Force | Out-Null
          }
          # export ke env untuk step-step berikutnya
          "LOGDIR=$root" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
          Write-Host "LOGDIR=$root"


      # ===== Preflight STAGING =====
      - name: Echo target
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          if "%H%"=="" ( echo Secret STG_DB_HOST is empty & exit /b 1 )
          echo Using sqlcmd: %SQLCMD_EXE%
          echo Target: %H%,%PORT% / DB=%D%

      - name: DNS resolve
        env:
          H: ${{ secrets.STG_DB_HOST }}
        run: nslookup %H% || (echo DNS FAILED & exit /b 1)

      - name: TCP port check
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          powershell -Command "if(!(Test-NetConnection -ComputerName '%H%' -Port ([int]'%PORT%') -InformationLevel Quiet)){exit 1}"

      - name: Test sqlcmd login (SELECT 1)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
        run: |
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"
          "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -l 10 -b -C -Q "SELECT 1"
          if errorlevel 1 exit /b 1

      # ===== QC Guards sebelum eksekusi =====
      - name: Block disallowed types (MAX, legacy LOB)
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          $files = Get-ChildItem -Path 'deploy' -Filter '*.sql' -Recurse -ErrorAction SilentlyContinue
          if (-not $files) { Write-Host 'No SQL files under deploy/.'; exit 0 }
          $patMax    = '\b(?:n?varchar|varbinary)\s*\(\s*max\s*\)'
          $patLegacy = '\b(?:text|ntext|image)\b'
          if (Select-String -Path $files.FullName -Pattern $patMax)    { throw 'Contains (var|nvar)char(max)/varbinary(max)' }
          if (Select-String -Path $files.FullName -Pattern $patLegacy) { throw 'Contains legacy type (text/ntext/image)' }

      - name: Extra guards (optional)
        shell: powershell
        run: |
          $ErrorActionPreference='Stop'
          $files = Get-ChildItem -Path 'deploy' -Filter '*.sql' -Recurse -ErrorAction SilentlyContinue
          if (-not $files) { exit 0 }
          $badAnsiNulls = '\bSET\s+ANSI_NULLS\s+OFF\b'
          $badQuotedId  = '\bSET\s+QUOTED_IDENTIFIER\s+OFF\b'
          if (Select-String -Path $files.FullName -Pattern $badAnsiNulls) { throw 'Found SET ANSI_NULLS OFF' }
          if (Select-String -Path $files.FullName -Pattern $badQuotedId)  { throw 'Found SET QUOTED_IDENTIFIER OFF' }

      - name: SQL parse-only (syntax check, no execution)
        shell: powershell
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
          LOGDIR: ${{ env.LOGDIR }}
        run: |
          $ErrorActionPreference = 'Stop'

          # Pastikan LOGDIR ada (fallback jika tidak diexport)
          $logRoot = if ($env:LOGDIR -and $env:LOGDIR.Trim().Length -gt 0) {
            $env:LOGDIR
          } else {
            Join-Path $env:GITHUB_WORKSPACE 'deploy_logs'
          }
          if (!(Test-Path -LiteralPath $logRoot)) {
            New-Item -ItemType Directory -Path $logRoot -Force | Out-Null
          }

          $port   = if ($env:P) { $env:P } else { "1433" }
          $master = Join-Path $logRoot "parseonly.log"

          # Kumpulkan semua file deploy/*.sql
          $files = Get-ChildItem -Path 'deploy' -Filter '*.sql' -ErrorAction SilentlyContinue
          if (-not $files) {
            "No SQL to parse." | Tee-Object -FilePath $master -Append
            exit 0
          }

          "== PARSE ONLY via wrapper (-i) ==" | Set-Content -LiteralPath $master -Encoding UTF8
          "Server=$($env:H), Port=$port, DB=$($env:D)" | Add-Content -LiteralPath $master -Encoding UTF8
          "sqlcmd=$env:SQLCMD_EXE" | Add-Content -LiteralPath $master -Encoding UTF8
          "" | Add-Content -LiteralPath $master -Encoding UTF8

          foreach ($f in $files) {
            # Path absolut file SQL
            $srcAbs = [IO.Path]::GetFullPath($f.FullName)
            # Normalisasi path untuk directive :r (tanpa kutip, pakai slash)
            $srcForR = $srcAbs -replace '\\','/'
            }

            $wrap = Join-Path $logRoot ("__parse_" + $f.BaseName + ".sql")
            $out  = Join-Path $logRoot ("parse_" + $f.BaseName + ".log")

            # Bangun wrapper: gunakan NOEXEC agar hanya compile (tanpa eksekusi)
            $wrapper = @"
            :ON ERROR EXIT
            SET NOEXEC ON
            :r $srcForR
            SET NOEXEC OFF
            "@
                $wrapper | Set-Content -LiteralPath $wrap -Encoding ASCII

                # Tulis info wrapper ke master log
                "WRAPPER: $wrap" | Tee-Object -FilePath $master -Append
                "SOURCE : $srcAbs"  | Tee-Object -FilePath $master -Append
                "----- wrapper content begin -----" | Tee-Object -FilePath $master -Append
                Get-Content -LiteralPath $wrap | Tee-Object -FilePath $master -Append
                "----- wrapper content end   -----" | Tee-Object -FilePath $master -Append

                # Jalankan wrapper dengan -i (BUKAN -Q). Hilangkan -f (tidak didukung di beberapa sqlcmd lama).
                & "$env:SQLCMD_EXE" `
                  -S "$($env:H),$port" -d "$($env:D)" -U "$($env:U)" -P "$env:W" `
                  -b -C -i "$wrap" -o "$out"

                if ($LASTEXITCODE -ne 0) {
                  "FAILED -> $srcAbs (see $out)" | Tee-Object -FilePath $master -Append
                  if (Test-Path -LiteralPath $out) {
                    Get-Content -LiteralPath $out -Tail 100 | Tee-Object -FilePath $master -Append
                  } else {
                    "Log file not found (sqlcmd stopped early)" | Tee-Object -FilePath $master -Append
                  }
                  throw ("Parse failed: {0}" -f $f.Name)
                } else {
                  "OK -> $srcAbs" | Tee-Object -FilePath $master -Append
                }
                "" | Add-Content -LiteralPath $master -Encoding UTF8
              }



      # (opsional) tampilkan tail di UI kalau parse-only gagal
      - name: Show parse-only tail when it failed
        if: ${{ steps.parseonly.outcome == 'failure' }}
        shell: powershell
        env:
          LOGDIR: ${{ env.LOGDIR }}
        run: |
          $master = if ($env:LOGDIR) { Join-Path $env:LOGDIR 'parseonly.log' } else { Join-Path $env:GITHUB_WORKSPACE 'deploy_logs\parseonly.log' }
          if (Test-Path -LiteralPath $master) {
            Write-Host "----- tail parseonly.log -----"
            Get-Content -LiteralPath $master -Tail 200 | Write-Host
            Write-Host "--------------------------------"
          } else {
            Write-Host "parseonly.log not found."
          }



      # ===== DEPLOY STAGING =====
      - name: Deploy to STAGING (deploy/*.sql sorted)
        env:
          H: ${{ secrets.STG_DB_HOST }}
          P: ${{ secrets.STG_DB_PORT }}
          D: ${{ secrets.STG_DB_NAME }}
          U: ${{ secrets.STG_DB_USER }}
          W: ${{ secrets.STG_DB_PASSWORD }}
          LOGDIR: ${{ env.LOGDIR }}
        run: |
          setlocal enabledelayedexpansion
          set "PORT=%P%"
          if "%PORT%"=="" set "PORT=1433"

          rem fallback jika LOGDIR kosong
          if "%LOGDIR%"=="" set "LOGDIR=%CD%\deploy_logs"
          if not exist "%LOGDIR%" mkdir "%LOGDIR%"

          if not exist deploy\*.sql (
            echo No SQL files in deploy\ .
            exit /b 0
          )

          echo Running deploy scripts on %H%,%PORT% [DB=%D%] ...
          for /f "delims=" %%F in ('dir /b /o:n deploy\*.sql') do (
            set "OUTLOG=%LOGDIR%\%%~nF.out.txt"
            echo Executing %%F ... > "!OUTLOG!"
            "%SQLCMD_EXE%" -S %H%,%PORT% -d %D% -U %U% -P %W% -b -C -i "deploy\%%F" -o "!OUTLOG!"
            if errorlevel 1 (
              echo FAILED on %%F
              exit /b 1
            )
          )
          echo All deploy SQL executed successfully.


      # ===== COMMENT PR =====
      - name: Comment on PR (summary)
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions/github-script@v7
        env:
          TARGET_HOST: ${{ secrets.STG_DB_HOST }}
          TARGET_DB:   ${{ secrets.STG_DB_NAME }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request?.number;
            if (!pr) { core.setFailed('No pull_request in context'); return; }
            const body = [
              "### ✅ QC/QA passed & deployed to **staging**",
              `- Workflow: ${process.env.GITHUB_WORKFLOW}`,
              `- Target: \`${process.env.TARGET_HOST}\` / \`${process.env.TARGET_DB}\``,
              "",
              "Guards: type scan, ANSI/QUOTED, SQL parse-only, preflight (DNS/TCP/SELECT 1)."
            ].join("\n");
            await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr, body });

      - name: Upload deploy logs
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: staging-deploy-logs
          path: |
            deploy_logs/**
            deploy/*.sql
          if-no-files-found: warn

